From 26ae1b922a58661a1b011a07172ac5b8e2078996 Mon Sep 17 00:00:00 2001
From: Geunsik Lim <geunsik.lim@samsung.com>
Date: Mon, 18 Feb 2019 16:22:17 +0900
Subject: [PATCH] [Android/ARM64] Simple test code based on nnstreamer

This commit is to evaluate basic elements (e.g., multifiesrc, png)
to bring up Gstreamer + NNstreamer packages on Android devices.

**Changes
1. Created configuration files to support ndk-build.
2. Enabled ELF file that is called test as a sample test for Android platform
   - ./tests/nnstreamer_repo_dynamicity/tensor_repo_dynamic_test.c
   - Requird elements are multifilesrc and png element.
3. Added LOCAL_LD_FLAGS to specify the default path of linker64.
   - LOCAL_LDFLAGS := -fPIE -pie -Wl,-dynamic-linker,/data/nnstreamer/libandroid/linker64
4. Declared the default API
   -  APP_PLATFORM := android-21

** Base commit
```bash
commit dd13303bba97901a696aefc9161ae45a5237049d
Author: MyungJoo Ham <myungjoo.ham@samsung.com>
Date:   Wed Jan 30 19:14:15 2019 +0900

ubuntu$ git clone https://github.com/nnsuite/nnstreamer.git
ubuntu$ cd nnstreamer
ubuntu$ git checkout dd13303bba97901a696aefc9161ae45a5237049d
ubuntu$ git branch
``

** How to reproduct
```bash
ubuntu$ cd jni
ubuntu$ ndk-build -j$(nproc)
ubuntu$ pushd ../libs/arm64-v8a
ubuntu$ adb push ./test /data/nnstreamer/
ubuntu$ for i in *.so ; do echo $i ; adb push "$i" /data/nnstreamer/libgstreamer/; done;
ubuntu$ adb shell mv /data/nnstreamer/libgstreamer/libnnstreamer.so /data/nnstramer/libnnstreamer/
ubuntu$ popd
ubuntu$ adb shell /data/nnstreamer/test
```

Signed-off-by: Jijoong Moon <Jijoong.moon@amsung.com>
Signed-off-by: Geunsik Lim <geunsik.lim@samsung.com>
---
 gst/nnstreamer/meson.build                         |   36 +-
 gst/nnstreamer/nnstreamer.c                        |    7 +-
 gst/nnstreamer/nnstreamer_conf.c                   |   18 +-
 gst/nnstreamer/nnstreamer_subplugin.c              |   56 +-
 gst/nnstreamer/nnstreamer_subplugin.h              |    5 -
 .../tensor_aggregator/tensor_aggregator.c          |    3 +-
 gst/nnstreamer/tensor_common.c                     |  896 +-
 gst/nnstreamer/tensor_common.h                     |  258 +-
 gst/nnstreamer/tensor_converter/tensor_converter.c |    8 +-
 .../tensor_decoder/tensordec-boundingbox.c         |  319 +-
 gst/nnstreamer/tensor_decoder/tensordec-plugins.c  |    2 -
 gst/nnstreamer/tensor_filter/meson.build           |    8 +-
 gst/nnstreamer/tensor_filter/tensor_filter.c       |  115 +-
 gst/nnstreamer/tensor_filter/tensor_filter.h       |   94 +
 .../tensor_filter/tensor_filter_custom.c           |   60 +-
 .../tensor_filter/tensor_filter_tensorflow.c       |   50 +-
 .../tensor_filter/tensor_filter_tensorflow_core.cc |  129 +-
 .../tensor_filter/tensor_filter_tensorflow_core.h  |   27 +-
 .../tensor_filter/tensor_filter_tensorflow_lite.c  |   51 +-
 .../tensor_filter_tensorflow_lite_core.cc          |   22 +-
 .../tensor_filter_tensorflow_lite_core.h           |   24 +-
 gst/nnstreamer/tensor_reposink/tensor_reposink.h   |    2 +-
 gst/nnstreamer/tensor_reposrc/tensor_reposrc.h     |    2 +-
 gst/nnstreamer/tensor_transform/transform-orc.c    | 9285 ++++++++++++++++++++
 gst/nnstreamer/tensor_transform/transform-orc.h    |  171 +
 gst/nnstreamer/tensor_typedef.h                    |  173 -
 jni/Android.mk                                     |  401 +
 jni/Application.mk                                 |    4 +
 28 files changed, 11372 insertions(+), 854 deletions(-)
 create mode 100644 gst/nnstreamer/tensor_transform/transform-orc.c
 create mode 100644 gst/nnstreamer/tensor_transform/transform-orc.h
 create mode 100644 jni/Android.mk
 create mode 100644 jni/Application.mk

diff --git a/gst/nnstreamer/meson.build b/gst/nnstreamer/meson.build
index afcf497..69433ff 100644
--- a/gst/nnstreamer/meson.build
+++ b/gst/nnstreamer/meson.build
@@ -16,14 +16,6 @@ nnstreamer_base_deps = [
   thread_dep
 ]
 
-# Dependencies
-nnstreamer_plugin_api_base_deps = [
-  glib_dep,
-  gst_dep,
-  gst_video_dep,
-  gst_audio_dep,
-]
-
 if have_orcc
   nnstreamer_base_deps += [orc_dep]
 endif
@@ -44,20 +36,10 @@ foreach s : nnst_common_sources
   nnstreamer_sources += join_paths(meson.current_source_dir(), s)
 endforeach
 
-# Add nnstreamer API plugin sources
-nnst_plugin_api_sources = [
-  'nnstreamer_plugin_api.c'
-]
-
-foreach s : nnst_plugin_api_sources
-  nnstreamer_sources += join_paths(meson.current_source_dir(), s)
-endforeach
-
 # Common headers to be installed
 nnst_common_headers = [
   'tensor_typedef.h',
-  'tensor_filter_custom.h',
-  'nnstreamer_plugin_api.h'
+  'tensor_filter_custom.h'
 ]
 
 foreach h : nnst_common_headers
@@ -110,22 +92,6 @@ if get_option('default_library') == 'static'
   nnstreamer_lib = nnstreamer_static
 endif
 
-nnstreamer_plugin_api_shared = shared_library('nnstreamer_plugin_api',
-  nnst_plugin_api_sources,
-  dependencies: [nnstreamer_plugin_api_base_deps],
-  include_directories: nnstreamer_inc,
-  install: true,
-  install_dir: libs_install_dir
-)
-
-nnstreamer_plugin_api_static = static_library('nnstreamer_plugin_api',
-  nnst_plugin_api_sources,
-  dependencies: [nnstreamer_plugin_api_base_deps],
-  include_directories: nnstreamer_inc,
-  install: true,
-  install_dir: libs_install_dir
-)
-
 nnstreamer_dep = declare_dependency(link_with: nnstreamer_lib,
   sources: nnstreamer_generated,
   dependencies: nnstreamer_base_deps,
diff --git a/gst/nnstreamer/nnstreamer.c b/gst/nnstreamer/nnstreamer.c
index 86a178d..3b09f22 100644
--- a/gst/nnstreamer/nnstreamer.c
+++ b/gst/nnstreamer/nnstreamer.c
@@ -57,7 +57,7 @@
 
 NNSTREAMER_PLUGIN (tensor_converter);
 NNSTREAMER_PLUGIN (tensor_aggregator);
-NNSTREAMER_PLUGIN (tensor_decoder);
+/* NNSTREAMER_PLUGIN (tensor_decoder); */
 NNSTREAMER_PLUGIN (tensor_demux);
 NNSTREAMER_PLUGIN (tensor_merge);
 NNSTREAMER_PLUGIN (tensor_mux);
@@ -89,7 +89,7 @@ gst_nnstreamer_init (GstPlugin * plugin)
 
   NNSTREAMER_INIT (tensor_converter, plugin);
   NNSTREAMER_INIT (tensor_aggregator, plugin);
-  NNSTREAMER_INIT (tensor_decoder, plugin);
+  /* NNSTREAMER_INIT (tensor_decoder, plugin); */
   NNSTREAMER_INIT (tensor_demux, plugin);
   NNSTREAMER_INIT (tensor_merge, plugin);
   NNSTREAMER_INIT (tensor_mux, plugin);
@@ -113,5 +113,6 @@ GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
     GST_VERSION_MINOR,
     nnstreamer,
     "nnstreamer plugin library",
-    gst_nnstreamer_init, VERSION, "LGPL", "nnstreamer",
+    /* gst_nnstreamer_init, VERSION, "LGPL", "nnstreamer", */
+    gst_nnstreamer_init, "0.1.0", "LGPL", "nnstreamer",		   
     "https://github.com/nnsuite/nnstreamer");
diff --git a/gst/nnstreamer/nnstreamer_conf.c b/gst/nnstreamer/nnstreamer_conf.c
index b3bc0a3..d5c913f 100644
--- a/gst/nnstreamer/nnstreamer_conf.c
+++ b/gst/nnstreamer/nnstreamer_conf.c
@@ -173,13 +173,8 @@ _fill_in_vstr (gchar *** fullpath_vstr, gchar *** basename_vstr,
   counterF = 0;
   counterB = 0;
   for (i = 0; i < CONF_SOURCES; i++) {
-    if (searchpath[i]) {
-      lstF = _get_fullpath_filenames (searchpath[i], lstF, &counterF);
-      lstB = _get_basenames (searchpath[i], lstB, &counterB);
-    } else {
-      lstF = _get_fullpath_filenames ("./", lstF, &counterF);
-      lstB = _get_basenames ("./", lstB, &counterB);
-    }
+    lstF = _get_fullpath_filenames (searchpath[i], lstF, &counterF);
+    lstB = _get_basenames (searchpath[i], lstB, &counterB);
   }
   g_assert (counterF == counterB);
 
@@ -190,9 +185,6 @@ _fill_in_vstr (gchar *** fullpath_vstr, gchar *** basename_vstr,
   *fullpath_vstr = g_malloc_n (counterF + 1, sizeof (gchar *));
   *basename_vstr = g_malloc_n (counterB + 1, sizeof (gchar *));
 
-  (*fullpath_vstr)[counterF] = NULL;
-  (*basename_vstr)[counterB] = NULL;
-
   vstrF.vstr = *fullpath_vstr;
   vstrB.vstr = *basename_vstr;
   vstrF.size = counterF;
@@ -209,7 +201,7 @@ _fill_in_vstr (gchar *** fullpath_vstr, gchar *** basename_vstr,
 
 /** @brief Public function defined in the header */
 gboolean
-nnsconf_loadconf (gboolean force_reload)
+nnstreamer_loadconf (gboolean force_reload)
 {
   g_autoptr (GError) error = NULL;
   g_autoptr (GKeyFile) key_file = NULL;
@@ -328,8 +320,8 @@ nnsconf_get_fullpath_fromfile (const gchar * file2find, nnsconf_type type)
 }
 
 const gchar *subplugin_prefixes[NNSCONF_END] = {
-  [NNSCONF_FILTERS] = NNSTREAMER_PREFIX_FILTER,
-  [NNSCONF_DECODERS] = NNSTREAMER_PREFIX_DECODER,
+  [NNSCONF_FILTERS] = NNSTREAMER_PREFIX_DECODER,
+  [NNSCONF_DECODERS] = NNSTREAMER_PREFIX_FILTER,
   [NNSCONF_CUSTOM_FILTERS] = NNSTREAMER_PREFIX_CUSTOMFILTERS,
   NULL,
 };
diff --git a/gst/nnstreamer/nnstreamer_subplugin.c b/gst/nnstreamer/nnstreamer_subplugin.c
index f1943e6..274cc8c 100644
--- a/gst/nnstreamer/nnstreamer_subplugin.c
+++ b/gst/nnstreamer/nnstreamer_subplugin.c
@@ -41,50 +41,6 @@ static GHashTable *subplugins[NNS_SUBPLUGIN_END] = { 0 };
 
 G_LOCK_DEFINE_STATIC (splock);
 
-
-typedef struct
-{
-  char *name;
-  const void *data;
-} holdplugins;
-static GHashTable *held_subplugins[NNS_SUBPLUGIN_END] = { 0 };
-
-/**
- * @brief Private function for g_hash_table data destructor, GDestroyNotify
- */
-static void
-_heldsp_destroy (gpointer _data)
-{
-  holdplugins *data = _data;
-  g_free (data->name);
-  /* do not free data here */
-  g_free (data);
-}
-
-/**
- * @brief API to notify subplugin-manager that this subplugin is handled already.
- */
-void
-hold_register_subplugin (subpluginType type, const char *name, void *data)
-{
-  if (held_subplugins[type] == NULL)
-    held_subplugins[type] =
-        g_hash_table_new_full (g_str_hash, g_str_equal, g_free,
-        _heldsp_destroy);
-  g_hash_table_insert (held_subplugins[type], g_strdup (name), data);
-}
-
-/**
- * @brief Check if this subplugin is held by hold_register_subplugin()
- */
-static const void *
-check_held_subplugin (subpluginType type, const char *name)
-{
-  if (held_subplugins[type] == NULL)
-    return NULL;
-  return g_hash_table_lookup (held_subplugins[type], name);
-}
-
 /** @brief Private function for g_hash_table data destructor, GDestroyNotify */
 static void
 _spdata_destroy (gpointer _data)
@@ -104,8 +60,6 @@ get_subplugin (subpluginType type, const char *name)
   subpluginData *data;
   void *handle;
 
-  nnsconf_loadconf (FALSE);
-
   G_LOCK (splock);
 
   if (subplugins[type] == NULL)
@@ -119,8 +73,7 @@ get_subplugin (subpluginType type, const char *name)
   if (data == NULL) {
     /* Search and register if found with the conf */
     const gchar *fullpath = nnsconf_get_fullpath (name, type);
-    char *dlsym_error;
-    const void *held;
+    const char *dlsym_error;
     nnstreamer_subplugin_data *nsdata;
 
     if (fullpath == NULL)
@@ -132,13 +85,6 @@ get_subplugin (subpluginType type, const char *name)
       goto error;
     }
 
-    /* If a plugin calls "probe()" at this step, stop here and return "OK" */
-    held = check_held_subplugin (type, name);
-    if (held) {
-      G_UNLOCK (splock);
-      return held;
-    }
-
     nsdata = (nnstreamer_subplugin_data *)
         dlsym (handle, "nnstreamer_subplugin");
     dlsym_error = dlerror ();
diff --git a/gst/nnstreamer/nnstreamer_subplugin.h b/gst/nnstreamer/nnstreamer_subplugin.h
index 0ee8e72..26e0377 100644
--- a/gst/nnstreamer/nnstreamer_subplugin.h
+++ b/gst/nnstreamer/nnstreamer_subplugin.h
@@ -87,9 +87,4 @@ register_subplugin (subpluginType type, const char *name, const void *data);
 extern gboolean
 unregister_subplugin (subpluginType type, const char *name);
 
-/**
- * @brief Call this at subplugin probe to avoid duplicated registration
- */
-extern void hold_register_subplugin (subpluginType type, const char *name, void *data);
-
 #endif /* __GST_NNSTREAMER_SUBPLUGIN_H__ */
diff --git a/gst/nnstreamer/tensor_aggregator/tensor_aggregator.c b/gst/nnstreamer/tensor_aggregator/tensor_aggregator.c
index 5d13be3..c207c20 100644
--- a/gst/nnstreamer/tensor_aggregator/tensor_aggregator.c
+++ b/gst/nnstreamer/tensor_aggregator/tensor_aggregator.c
@@ -569,8 +569,6 @@ gst_tensor_aggregator_concat (GstTensorAggregator * self, GstBuffer * outbuf,
   g_assert (frame_size > 0);
 
   srcbuf = gst_buffer_copy (outbuf);
-  outbuf = gst_buffer_make_writable (outbuf);
-
   g_assert (gst_buffer_map (srcbuf, &src_info, GST_MAP_READ));
   g_assert (gst_buffer_map (outbuf, &dest_info, GST_MAP_WRITE));
 
@@ -826,6 +824,7 @@ gst_tensor_aggregator_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
 
   if (frames_in == frames_out) {
     /** push the incoming buffer (do concat if needed) */
+    buf = gst_buffer_make_writable (buf);
     return gst_tensor_aggregator_push (self, buf, frame_size);
   }
 
diff --git a/gst/nnstreamer/tensor_common.c b/gst/nnstreamer/tensor_common.c
index b396c93..2b7b681 100644
--- a/gst/nnstreamer/tensor_common.c
+++ b/gst/nnstreamer/tensor_common.c
@@ -26,6 +26,110 @@
 #include <tensor_common.h>
 #include <string.h>
 #include <glib.h>
+#include <stdio.h>
+
+/**
+ * @brief String representations for each tensor element type.
+ */
+const gchar *tensor_element_typename[] = {
+  [_NNS_INT32] = "int32",
+  [_NNS_UINT32] = "uint32",
+  [_NNS_INT16] = "int16",
+  [_NNS_UINT16] = "uint16",
+  [_NNS_INT8] = "int8",
+  [_NNS_UINT8] = "uint8",
+  [_NNS_FLOAT64] = "float64",
+  [_NNS_FLOAT32] = "float32",
+  [_NNS_INT64] = "int64",
+  [_NNS_UINT64] = "uint64",
+  [_NNS_END] = NULL,
+};
+
+/**
+ * @brief Get media type from structure
+ * @param structure structure to be interpreted
+ * @return corresponding media type (returns _NNS_MEDIA_END for unsupported type)
+ */
+media_type
+gst_tensor_media_type_from_structure (const GstStructure * structure)
+{
+  const gchar *name;
+
+  name = gst_structure_get_name (structure);
+
+  g_return_val_if_fail (name != NULL, _NNS_MEDIA_END);
+
+  if (g_str_has_prefix (name, "video/")) {
+    return _NNS_VIDEO;
+  }
+
+  if (g_str_has_prefix (name, "audio/")) {
+    return _NNS_AUDIO;
+  }
+
+  if (g_str_has_prefix (name, "text/")) {
+    return _NNS_STRING;
+  }
+
+  if (g_str_equal (name, "application/octet-stream")) {
+    return _NNS_OCTET;
+  }
+
+  /** unknown, or not-supported type */
+  return _NNS_MEDIA_END;
+}
+
+/**
+ * @brief Get media type from caps
+ * @param caps caps to be interpreted
+ * @return corresponding media type (returns _NNS_MEDIA_END for unsupported type)
+ */
+media_type
+gst_tensor_media_type_from_caps (const GstCaps * caps)
+{
+  GstStructure *structure;
+
+  structure = gst_caps_get_structure (caps, 0);
+
+  return gst_tensor_media_type_from_structure (structure);
+}
+
+/**
+ * @brief Initialize the tensor info structure
+ * @param info tensor info structure to be initialized
+ */
+void
+gst_tensor_info_init (GstTensorInfo * info)
+{
+  guint i;
+
+  g_return_if_fail (info != NULL);
+
+  info->name = NULL;
+  info->type = _NNS_END;
+
+  for (i = 0; i < NNS_TENSOR_RANK_LIMIT; i++) {
+    info->dimension[i] = 0;
+  }
+}
+
+/**
+ * @brief Check the tensor info is valid
+ * @param info tensor info structure
+ * @return TRUE if info is valid
+ */
+gboolean
+gst_tensor_info_validate (const GstTensorInfo * info)
+{
+  g_return_val_if_fail (info != NULL, FALSE);
+
+  if (info->type == _NNS_END) {
+    return FALSE;
+  }
+
+  /* validate tensor dimension */
+  return gst_tensor_dimension_is_valid (info->dimension);
+}
 
 /**
  * @brief Compare tensor info
@@ -54,26 +158,67 @@ gst_tensor_info_is_equal (const GstTensorInfo * i1, const GstTensorInfo * i2)
 }
 
 /**
- * @brief Copy tensor info
- * @note GstTensorInfo::name should be freed with g_free()
+ * @brief Get data size of single tensor
+ * @param info tensor info structure
+ * @return data size
+ */
+gsize
+gst_tensor_info_get_size (const GstTensorInfo * info)
+{
+  gsize data_size;
+
+  g_return_val_if_fail (info != NULL, 0);
+
+  data_size = get_tensor_element_count (info->dimension) *
+      tensor_element_size[info->type];
+
+  return data_size;
+}
+
+/**
+ * @brief Initialize the tensors info structure
+ * @param info tensors info structure to be initialized
  */
 void
-gst_tensor_info_copy (GstTensorInfo * dest, const GstTensorInfo * src)
+gst_tensors_info_init (GstTensorsInfo * info)
 {
   guint i;
 
-  g_return_if_fail (dest != NULL);
-  g_return_if_fail (src != NULL);
+  g_return_if_fail (info != NULL);
 
-  dest->name = (src->name) ? g_strdup (src->name) : NULL;
-  dest->type = src->type;
+  info->num_tensors = 0;
 
-  for (i = 0; i < NNS_TENSOR_RANK_LIMIT; i++) {
-    dest->dimension[i] = src->dimension[i];
+  for (i = 0; i < NNS_TENSOR_SIZE_LIMIT; i++) {
+    gst_tensor_info_init (&info->info[i]);
   }
 }
 
 /**
+ * @brief Check the tensors info is valid
+ * @param info tensors info structure
+ * @return TRUE if info is valid
+ */
+gboolean
+gst_tensors_info_validate (const GstTensorsInfo * info)
+{
+  guint i;
+
+  g_return_val_if_fail (info != NULL, FALSE);
+
+  if (info->num_tensors < 1) {
+    return FALSE;
+  }
+
+  for (i = 0; i < info->num_tensors; i++) {
+    if (!gst_tensor_info_validate (&info->info[i])) {
+      return FALSE;
+    }
+  }
+
+  return TRUE;
+}
+
+/**
  * @brief Compare tensors info
  * @param TRUE if equal
  */
@@ -100,22 +245,79 @@ gst_tensors_info_is_equal (const GstTensorsInfo * i1, const GstTensorsInfo * i2)
 }
 
 /**
- * @brief Copy tensor info
- * @note GstTensorInfo::name should be freed with g_free()
+ * @brief Parse the string of dimensions
+ * @param info tensors info structure
+ * @param dim_string string of dimensions
+ * @return number of parsed dimensions
  */
-void
-gst_tensors_info_copy (GstTensorsInfo * dest, const GstTensorsInfo * src)
+guint
+gst_tensors_info_parse_dimensions_string (GstTensorsInfo * info,
+    const gchar * dim_string)
 {
-  guint i;
+  guint num_dims = 0;
+
+  g_return_val_if_fail (info != NULL, 0);
+
+  if (dim_string) {
+    guint i;
+    gchar **str_dims;
+
+    str_dims = g_strsplit (dim_string, ",", -1);
+    num_dims = g_strv_length (str_dims);
+
+    if (num_dims > NNS_TENSOR_SIZE_LIMIT) {
+      GST_WARNING ("Invalid param, dimensions (%d) max (%d)\n",
+          num_dims, NNS_TENSOR_SIZE_LIMIT);
+
+      num_dims = NNS_TENSOR_SIZE_LIMIT;
+    }
+
+    for (i = 0; i < num_dims; i++) {
+      get_tensor_dimension (str_dims[i], info->info[i].dimension);
+    }
+
+    g_strfreev (str_dims);
+  }
+
+  return num_dims;
+}
+
+/**
+ * @brief Parse the string of types
+ * @param info tensors info structure
+ * @param type_string string of types
+ * @return number of parsed types
+ */
+guint
+gst_tensors_info_parse_types_string (GstTensorsInfo * info,
+    const gchar * type_string)
+{
+  gint num_types = 0;
+
+  g_return_val_if_fail (info != NULL, 0);
+
+  if (type_string && !g_str_equal(type_string, "ANY")) {
+    guint i;
+    gchar **str_types;
 
-  g_return_if_fail (dest != NULL);
-  g_return_if_fail (src != NULL);
+    str_types = g_strsplit (type_string, ",", -1);
+    num_types = g_strv_length (str_types);
 
-  dest->num_tensors = src->num_tensors;
+    if (num_types > NNS_TENSOR_SIZE_LIMIT) {
+      GST_WARNING ("Invalid param, types (%d) max (%d)\n",
+          num_types, NNS_TENSOR_SIZE_LIMIT);
+
+      num_types = NNS_TENSOR_SIZE_LIMIT;
+    }
 
-  for (i = 0; i < src->num_tensors; i++) {
-    gst_tensor_info_copy (&dest->info[i], &src->info[i]);
+    for (i = 0; i < num_types; i++) {
+      info->info[i].type = get_tensor_type (str_types[i]);
+    }
+
+    g_strfreev (str_types);
   }
+
+  return num_types;
 }
 
 /**
@@ -259,6 +461,41 @@ gst_tensors_info_get_names_string (const GstTensorsInfo * info)
 }
 
 /**
+ * @brief Initialize the tensor config info structure
+ * @param config tensor config structure to be initialized
+ */
+void
+gst_tensor_config_init (GstTensorConfig * config)
+{
+  g_return_if_fail (config != NULL);
+
+  gst_tensor_info_init (&config->info);
+
+  config->rate_n = -1;
+  config->rate_d = -1;
+}
+
+/**
+ * @brief Check the tensor is all configured
+ * @param config tensor config structure
+ * @return TRUE if configured
+ */
+gboolean
+gst_tensor_config_validate (const GstTensorConfig * config)
+{
+  g_return_val_if_fail (config != NULL, FALSE);
+
+  /**
+   * check framerate (numerator >= 0 and denominator > 0)
+   */
+  if (config->rate_n < 0 || config->rate_d <= 0) {
+    return FALSE;
+  }
+
+  return gst_tensor_info_validate (&config->info);
+}
+
+/**
  * @brief Compare tensor config info
  * @param TRUE if equal
  */
@@ -278,6 +515,344 @@ gst_tensor_config_is_equal (const GstTensorConfig * c1,
 }
 
 /**
+ * @brief Parse structure and set tensor config info (internal static function)
+ * @param config tensor config structure to be filled
+ * @param structure structure to be interpreted
+ * @return TRUE if ok
+ */
+static gboolean
+gst_tensor_config_from_tensor_structure (GstTensorConfig * config,
+    const GstStructure * structure)
+{
+  GstTensorInfo *info;
+
+  g_return_val_if_fail (config != NULL, FALSE);
+  gst_tensor_config_init (config);
+  info = &config->info;
+
+  g_return_val_if_fail (structure != NULL, FALSE);
+
+  if (!gst_structure_has_name (structure, "other/tensor")) {
+    GST_WARNING ("caps is not tensor %s\n", gst_structure_get_name (structure));
+    return FALSE;
+  }
+
+  if (gst_structure_has_field (structure, "dimension")) {
+    const gchar *dim_str = gst_structure_get_string (structure, "dimension");
+    get_tensor_dimension (dim_str, info->dimension);
+  }
+
+  if (gst_structure_has_field (structure, "type")) {
+    const gchar *type_str = gst_structure_get_string (structure, "type");
+    info->type = get_tensor_type (type_str);
+  }
+
+  gst_structure_get_fraction (structure, "framerate", &config->rate_n,
+      &config->rate_d);
+
+  return TRUE;
+}
+
+/**
+ * @brief Set the tensor config structure from video info (internal static function)
+ * @param config tensor config structure to be filled
+ * @param structure caps structure
+ * @note Change dimention if tensor contains N frames.
+ * @return TRUE if supported type
+ */
+static gboolean
+gst_tensor_config_from_video_info (GstTensorConfig * config,
+    const GstStructure * structure)
+{
+  /**
+   * Refer: https://www.tensorflow.org/api_docs/python/tf/summary/image
+   * A 4-D uint8 or float32 Tensor of shape [batch_size, height, width, channels]
+   * where channels is 1, 3, or 4.
+   */
+  const gchar *format_string;
+  GstVideoFormat format = GST_VIDEO_FORMAT_UNKNOWN;
+  gint width = 0;
+  gint height = 0;
+
+  g_return_val_if_fail (config != NULL, FALSE);
+  gst_tensor_config_init (config);
+
+  g_return_val_if_fail (structure != NULL, FALSE);
+
+  format_string = gst_structure_get_string (structure, "format");
+  if (format_string) {
+    format = gst_video_format_from_string (format_string);
+  }
+
+  gst_structure_get_int (structure, "width", &width);
+  gst_structure_get_int (structure, "height", &height);
+  gst_structure_get_fraction (structure, "framerate", &config->rate_n,
+      &config->rate_d);
+
+  /** [color-space][width][height][frames] */
+  switch (format) {
+    case GST_VIDEO_FORMAT_GRAY8:
+      config->info.type = _NNS_UINT8;
+      config->info.dimension[0] = 1;
+      break;
+    case GST_VIDEO_FORMAT_RGB:
+    case GST_VIDEO_FORMAT_BGR:
+      config->info.type = _NNS_UINT8;
+      config->info.dimension[0] = 3;
+      break;
+    case GST_VIDEO_FORMAT_RGBx:
+    case GST_VIDEO_FORMAT_BGRx:
+    case GST_VIDEO_FORMAT_xRGB:
+    case GST_VIDEO_FORMAT_xBGR:
+    case GST_VIDEO_FORMAT_RGBA:
+    case GST_VIDEO_FORMAT_BGRA:
+    case GST_VIDEO_FORMAT_ARGB:
+    case GST_VIDEO_FORMAT_ABGR:
+      config->info.type = _NNS_UINT8;
+      config->info.dimension[0] = 4;
+      break;
+    default:
+      /** unsupported format */
+      GST_WARNING ("Unsupported format = %s\n",
+          format_string ? format_string : "Unknown");
+      break;
+  }
+
+  config->info.dimension[1] = width;
+  config->info.dimension[2] = height;
+  config->info.dimension[3] = 1; /** Supposed 1 frame in tensor, change this if tensor contains N frames. */
+#if 0
+  /**
+   * @todo To fix coverity issue, now block these lines.
+   * If NNS_TENSOR_RANK_LIMIT is larger than 4, unblock these to initialize the tensor dimension.
+   */
+  gint i;
+  for (i = 4; i < NNS_TENSOR_RANK_LIMIT; i++) {
+    config->info.dimension[i] = 1;
+  }
+#endif
+  return (config->info.type != _NNS_END);
+}
+
+/**
+ * @brief Set the tensor config structure from audio info (internal static function)
+ * @param config tensor config structure to be filled
+ * @param structure caps structure
+ * @note Change dimention if tensor contains N frames.
+ * @return TRUE if supported type
+ */
+static gboolean
+gst_tensor_config_from_audio_info (GstTensorConfig * config,
+    const GstStructure * structure)
+{
+  /**
+   * Refer: https://www.tensorflow.org/api_docs/python/tf/summary/audio
+   * A 3-D float32 Tensor of shape [batch_size, frames, channels]
+   * or a 2-D float32 Tensor of shape [batch_size, frames].
+   */
+  const gchar *format_string;
+  GstAudioFormat format = GST_AUDIO_FORMAT_UNKNOWN;
+  gint channels = 0;
+  gint rate = 0;
+  gint i;
+
+  g_return_val_if_fail (config != NULL, FALSE);
+  gst_tensor_config_init (config);
+
+  g_return_val_if_fail (structure != NULL, FALSE);
+
+  format_string = gst_structure_get_string (structure, "format");
+  if (format_string) {
+    format = gst_audio_format_from_string (format_string);
+  }
+
+  gst_structure_get_int (structure, "channels", &channels);
+  gst_structure_get_int (structure, "rate", &rate);
+
+  /** [channels][frames] */
+  switch (format) {
+    case GST_AUDIO_FORMAT_S8:
+      config->info.type = _NNS_INT8;
+      break;
+    case GST_AUDIO_FORMAT_U8:
+      config->info.type = _NNS_UINT8;
+      break;
+    case GST_AUDIO_FORMAT_S16:
+      config->info.type = _NNS_INT16;
+      break;
+    case GST_AUDIO_FORMAT_U16:
+      config->info.type = _NNS_UINT16;
+      break;
+    case GST_AUDIO_FORMAT_S32:
+      config->info.type = _NNS_INT32;
+      break;
+    case GST_AUDIO_FORMAT_U32:
+      config->info.type = _NNS_UINT32;
+      break;
+    case GST_AUDIO_FORMAT_F32:
+      config->info.type = _NNS_FLOAT32;
+      break;
+    case GST_AUDIO_FORMAT_F64:
+      config->info.type = _NNS_FLOAT64;
+      break;
+    default:
+      /** unsupported format */
+      GST_WARNING ("Unsupported format = %s\n",
+          format_string ? format_string : "Unknown");
+      break;
+  }
+
+  config->info.dimension[0] = channels;
+  config->info.dimension[1] = 1; /** Supposed 1 frame in tensor, change this if tensor contains N frames */
+
+  for (i = 2; i < NNS_TENSOR_RANK_LIMIT; i++) {
+    config->info.dimension[i] = 1;
+  }
+
+  if (rate > 0) {
+    config->rate_n = rate;
+    config->rate_d = 1;
+  }
+
+  return (config->info.type != _NNS_END);
+}
+
+/**
+ * @brief Set the tensor config structure from text info (internal static function)
+ * @param config tensor config structure to be filled
+ * @param structure caps structure
+ * @note Change dimention if tensor contains N frames.
+ * @return TRUE if supported type
+ */
+static gboolean
+gst_tensor_config_from_text_info (GstTensorConfig * config,
+    const GstStructure * structure)
+{
+  /**
+   * Refer: https://www.tensorflow.org/api_docs/python/tf/summary/text
+   * A string-type Tensor
+   */
+  const gchar *format_string;
+  gint i;
+
+  g_return_val_if_fail (config != NULL, FALSE);
+  gst_tensor_config_init (config);
+
+  g_return_val_if_fail (structure != NULL, FALSE);
+
+  format_string = gst_structure_get_string (structure, "format");
+  if (format_string) {
+    if (g_str_equal (format_string, "utf8")) {
+      config->info.type = _NNS_UINT8;
+    } else {
+      /** unsupported format */
+      GST_WARNING ("Unsupported format = %s\n", format_string);
+    }
+  }
+
+  /** [size][frames] */
+  config->info.dimension[0] = GST_TENSOR_STRING_SIZE; /** fixed size of string */
+  config->info.dimension[1] = 1; /** Supposed 1 frame in tensor, change this if tensor contains N frames */
+
+  for (i = 2; i < NNS_TENSOR_RANK_LIMIT; i++) {
+    config->info.dimension[i] = 1;
+  }
+
+  if (gst_structure_has_field (structure, "framerate")) {
+    gst_structure_get_fraction (structure, "framerate", &config->rate_n,
+        &config->rate_d);
+  } else {
+    /** cannot get the framerate for text type */
+    config->rate_n = 0;
+    config->rate_d = 1;
+  }
+
+  return (config->info.type != _NNS_END);
+}
+
+/**
+ * @brief Set the tensor config structure from octet stream (internal static function)
+ * @param config tensor config structure to be filled
+ * @param structure caps structure
+ * @note Change tensor dimention and type.
+ * @return TRUE if supported type
+ */
+static gboolean
+gst_tensor_config_from_octet_stream_info (GstTensorConfig * config,
+    const GstStructure * structure)
+{
+  g_return_val_if_fail (config != NULL, FALSE);
+  gst_tensor_config_init (config);
+
+  g_return_val_if_fail (structure != NULL, FALSE);
+
+  /**
+   * Raw byte-stream (application/octet-stream)
+   * We cannot get the exact tensor info from caps.
+   * All tensor info should be updated.
+   */
+  config->info.type = _NNS_UINT8;
+
+  if (gst_structure_has_field (structure, "framerate")) {
+    gst_structure_get_fraction (structure, "framerate", &config->rate_n,
+        &config->rate_d);
+  } else {
+    /** cannot get the framerate */
+    config->rate_n = 0;
+    config->rate_d = 1;
+  }
+
+  return (config->info.type != _NNS_END);
+}
+
+/**
+ * @brief Parse structure and set tensor config info
+ * @param config tensor config structure to be filled
+ * @param structure structure to be interpreted
+ * @note Change dimention if tensor contains N frames.
+ * @return TRUE if no error
+ */
+gboolean
+gst_tensor_config_from_structure (GstTensorConfig * config,
+    const GstStructure * structure)
+{
+  media_type m_type;
+
+  g_return_val_if_fail (config != NULL, FALSE);
+  gst_tensor_config_init (config);
+
+  g_return_val_if_fail (structure != NULL, FALSE);
+
+  /** update config from tensor stream */
+  if (gst_structure_has_name (structure, "other/tensor")) {
+    return gst_tensor_config_from_tensor_structure (config, structure);
+  }
+
+  /** update config from media stream */
+  m_type = gst_tensor_media_type_from_structure (structure);
+
+  switch (m_type) {
+    case _NNS_VIDEO:
+      gst_tensor_config_from_video_info (config, structure);
+      break;
+    case _NNS_AUDIO:
+      gst_tensor_config_from_audio_info (config, structure);
+      break;
+    case _NNS_STRING:
+      gst_tensor_config_from_text_info (config, structure);
+      break;
+    case _NNS_OCTET:
+      gst_tensor_config_from_octet_stream_info (config, structure);
+      break;
+    default:
+      GST_WARNING ("Unsupported type %d\n", m_type);
+      return FALSE;
+  }
+
+  return TRUE;
+}
+
+/**
  * @brief Get tensor caps from tensor config
  * @param config tensor config info
  * @return caps for given config
@@ -312,6 +887,41 @@ gst_tensor_caps_from_config (const GstTensorConfig * config)
 }
 
 /**
+ * @brief Initialize the tensors config info structure (for other/tensors)
+ * @param config tensors config structure to be initialized
+ */
+void
+gst_tensors_config_init (GstTensorsConfig * config)
+{
+  g_return_if_fail (config != NULL);
+
+  gst_tensors_info_init (&config->info);
+
+  config->rate_n = -1;
+  config->rate_d = -1;
+}
+
+/**
+ * @brief Check the tensors are all configured
+ * @param config tensor config structure
+ * @return TRUE if configured
+ */
+gboolean
+gst_tensors_config_validate (const GstTensorsConfig * config)
+{
+  g_return_val_if_fail (config != NULL, FALSE);
+
+  /**
+   * check framerate (numerator >= 0 and denominator > 0)
+   */
+  if (config->rate_n < 0 || config->rate_d <= 0) {
+    return FALSE;
+  }
+
+  return gst_tensors_info_validate (&config->info);
+}
+
+/**
  * @brief Compare tensor config info
  * @param TRUE if equal
  */
@@ -330,6 +940,82 @@ gst_tensors_config_is_equal (const GstTensorsConfig * c1,
 }
 
 /**
+ * @brief Parse structure and set tensors config (for other/tensors)
+ * @param config tensors config structure to be filled
+ * @param structure structure to be interpreted
+ * @return TRUE if no error
+ */
+gboolean
+gst_tensors_config_from_structure (GstTensorsConfig * config,
+    const GstStructure * structure)
+{
+  const gchar *name;
+
+  g_return_val_if_fail (config != NULL, FALSE);
+  gst_tensors_config_init (config);
+
+  g_return_val_if_fail (structure != NULL, FALSE);
+
+  name = gst_structure_get_name (structure);
+
+  if (g_str_equal (name, "other/tensor")) {
+    GstTensorConfig c;
+
+    gst_tensor_config_from_tensor_structure (&c, structure);
+
+    config->info.num_tensors = 1;
+    config->info.info[0] = c.info;
+    config->rate_d = c.rate_d;
+    config->rate_n = c.rate_n;
+  } else if (g_str_equal (name, "other/tensors")) {
+    gst_structure_get_int (structure, "num_tensors",
+        (gint *) (&config->info.num_tensors));
+    gst_structure_get_fraction (structure, "framerate", &config->rate_n,
+        &config->rate_d);
+
+    if (config->info.num_tensors > NNS_TENSOR_SIZE_LIMIT) {
+      GST_WARNING ("Invalid param, max size is %d", NNS_TENSOR_SIZE_LIMIT);
+      config->info.num_tensors = NNS_TENSOR_SIZE_LIMIT;
+    }
+
+    /* parse dimensions */
+    if (gst_structure_has_field (structure, "dimensions")) {
+      const gchar *dims_str;
+      guint num_dims;
+
+      dims_str = gst_structure_get_string (structure, "dimensions");
+      num_dims =
+          gst_tensors_info_parse_dimensions_string (&config->info, dims_str);
+
+      if (config->info.num_tensors != num_dims) {
+        GST_WARNING ("Invalid param, dimensions (%d) tensors (%d)\n",
+            num_dims, config->info.num_tensors);
+      }
+    }
+
+    /* parse types */
+    if (gst_structure_has_field (structure, "types")) {
+      const gchar *types_str;
+      guint num_types;
+
+      types_str = gst_structure_get_string (structure, "types");
+      num_types =
+          gst_tensors_info_parse_types_string (&config->info, types_str);
+
+      if (config->info.num_tensors != num_types) {
+        GST_WARNING ("Invalid param, types (%d) tensors (%d)\n",
+            num_types, config->info.num_tensors);
+      }
+    }
+  } else {
+    GST_WARNING ("Unsupported type = %s\n", name ? name : "Unknown");
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+/**
  * @brief Get caps from tensors config (for other/tensors)
  * @param config tensors config info
  * @return caps for given config
@@ -367,6 +1053,73 @@ gst_tensors_caps_from_config (const GstTensorsConfig * config)
 }
 
 /**
+ * @brief Get tensor_type from string tensor_type input
+ * @return Corresponding tensor_type. _NNS_END if unrecognized value is there.
+ * @param typestr The string type name, supposed to be one of tensor_element_typename[]
+ */
+tensor_type
+get_tensor_type (const gchar * typestr)
+{
+  int len;
+  gchar *type_string;
+  tensor_type type = _NNS_END;
+
+  if (typestr == NULL || g_str_equal(typestr,"ANY"))
+    return _NNS_END;
+
+  /** remove spaces */
+  type_string = g_strdup (typestr);
+  g_strstrip (type_string);
+
+  len = strlen (type_string);
+
+  if (type_string[0] == 'u' || type_string[0] == 'U') {
+    /**
+     * Let's believe the developer and the following three letters are "int"
+     * (case insensitive)
+     */
+    if (len == 6) {             /* uint16, uint32 */
+      if (type_string[4] == '1' && type_string[5] == '6')
+        type = _NNS_UINT16;
+      else if (type_string[4] == '3' && type_string[5] == '2')
+        type = _NNS_UINT32;
+      else if (type_string[4] == '6' && type_string[5] == '4')
+        type = _NNS_UINT64;
+    } else if (len == 5) {      /* uint8 */
+      if (type_string[4] == '8')
+        type = _NNS_UINT8;
+    }
+  } else if (type_string[0] == 'i' || type_string[0] == 'I') {
+    /**
+     * Let's believe the developer and the following two letters are "nt"
+     * (case insensitive)
+     */
+    if (len == 5) {             /* int16, int32 */
+      if (type_string[3] == '1' && type_string[4] == '6')
+        type = _NNS_INT16;
+      else if (type_string[3] == '3' && type_string[4] == '2')
+        type = _NNS_INT32;
+      else if (type_string[3] == '6' && type_string[4] == '4')
+        type = _NNS_INT64;
+    } else if (len == 4) {      /* int8 */
+      if (type_string[3] == '8')
+        type = _NNS_INT8;
+    }
+  } else if (type_string[0] == 'f' || type_string[0] == 'F') {
+    /* Let's assume that the following 4 letters are "loat" */
+    if (len == 7) {
+      if (type_string[5] == '6' && type_string[6] == '4')
+        type = _NNS_FLOAT64;
+      else if (type_string[5] == '3' && type_string[6] == '2')
+        type = _NNS_FLOAT32;
+    }
+  }
+
+  g_free (type_string);
+  return type;
+}
+
+/**
  * @brief Find the index value of the given key string array
  * @return Corresponding index. Returns -1 if not found.
  * @param strv Null terminated array of gchar *
@@ -388,6 +1141,111 @@ find_key_strv (const gchar ** strv, const gchar * key)
 }
 
 /**
+ * @brief Check the tensor dimension is valid
+ * @param dim tensor dimension
+ * @return TRUE if dimension is valid
+ */
+gboolean
+gst_tensor_dimension_is_valid (const tensor_dim dim)
+{
+  guint i;
+
+  for (i = 0; i < NNS_TENSOR_RANK_LIMIT; ++i) {
+    if (dim[i] == 0) {
+      return FALSE;
+    }
+  }
+
+  return TRUE;
+}
+
+/**
+ * @brief Parse tensor dimension parameter string
+ * @return The Rank. 0 if error.
+ * @param dimstr The dimension string in the format of d1:d2:d3:d4, d1:d2:d3, d1:d2, or d1, where dN is a positive integer and d1 is the innermost dimension; i.e., dim[d4][d3][d2][d1];
+ * @param dim dimension to be filled.
+ */
+int
+get_tensor_dimension (const gchar * dimstr, tensor_dim dim)
+{
+  int rank = 0;
+  guint64 val;
+  gchar **strv;
+  gchar *dim_string;
+  gint i, num_dims;
+
+  if (dimstr == NULL || g_str_equal(dimstr,"ANY"))
+    return 0;
+
+  /** remove spaces */
+  dim_string = g_strdup (dimstr);
+  g_strstrip (dim_string);
+
+  strv = g_strsplit (dim_string, ":", NNS_TENSOR_RANK_LIMIT);
+  num_dims = g_strv_length (strv);
+
+  for (i = 0; i < num_dims; i++) {
+    g_strstrip (strv[i]);
+    if (strv[i] == NULL || strlen (strv[i]) == 0)
+      break;
+
+    val = g_ascii_strtoull (strv[i], NULL, 10);
+    dim[i] = (uint32_t) val;
+    rank = i + 1;
+  }
+
+  for (; i < NNS_TENSOR_RANK_LIMIT; i++)
+    dim[i] = 1;
+
+  g_strfreev (strv);
+  g_free (dim_string);
+  return rank;
+}
+
+/**
+ * @brief Get dimension string from given tensor dimension.
+ * @param dim tensor dimension
+ * @return Formatted string of given dimension (d1:d2:d3:d4).
+ * @note The returned value should be freed with g_free()
+ */
+gchar *
+get_tensor_dimension_string (const tensor_dim dim)
+{
+  gint i;
+  GString *dim_str;
+
+  dim_str = g_string_new (NULL);
+
+  for (i = 0; i < NNS_TENSOR_RANK_LIMIT; i++) {
+    g_string_append_printf (dim_str, "%d", dim[i]);
+
+    if (i < NNS_TENSOR_RANK_LIMIT - 1) {
+      g_string_append (dim_str, ":");
+    }
+  }
+
+  return g_string_free (dim_str, FALSE);
+}
+
+/**
+ * @brief Count the number of elemnts of a tensor
+ * @return The number of elements. 0 if error.
+ * @param dim The tensor dimension
+ */
+size_t
+get_tensor_element_count (const tensor_dim dim)
+{
+  size_t count = 1;
+  int i;
+
+  for (i = 0; i < NNS_TENSOR_RANK_LIMIT; i++) {
+    count *= dim[i];
+  }
+
+  return count;
+}
+
+/**
  * @brief A callback for typefind, trying to find whether a file is other/tensors or not.
  * For the concrete definition of headers, please look at the wiki page of nnstreamer:
  * https://github.com/nnsuite/nnstreamer/wiki/Design-External-Save-Format-for-other-tensor-and-other-tensors-Stream-for-TypeFind
diff --git a/gst/nnstreamer/tensor_common.h b/gst/nnstreamer/tensor_common.h
index 68a1000..aec6c86 100644
--- a/gst/nnstreamer/tensor_common.h
+++ b/gst/nnstreamer/tensor_common.h
@@ -38,8 +38,6 @@
 #include <gst/base/gstcollectpads.h>
 #include <gst/gstplugin.h>
 
-#include "nnstreamer_plugin_api.h"
-
 #ifdef HAVE_ORC
 #include <orc/orc.h>
 
@@ -56,6 +54,13 @@
 
 G_BEGIN_DECLS
 
+/**
+ * @brief Fixed size of string type
+ */
+#ifndef GST_TENSOR_STRING_SIZE
+#define GST_TENSOR_STRING_SIZE (1024)
+#endif
+
 #define GST_TENSOR_VIDEO_CAPS_STR \
     GST_VIDEO_CAPS_MAKE ("{ RGB, BGR, RGBx, BGRx, xRGB, xBGR, RGBA, BGRA, ARGB, ABGR, GRAY8 }") \
     ", views = (int) 1, interlace-mode = (string) progressive"
@@ -80,8 +85,91 @@ G_BEGIN_DECLS
     GST_TENSOR_TEXT_CAPS_STR "; " \
     GST_TENSOR_OCTET_CAPS_STR
 
+#define GST_TENSOR_RATE_RANGE "(fraction) [ 0, max ]"
 #define GST_TENSOR_TYPE_ALL "{ float32, float64, int64, uint64, int32, uint32, int16, uint16, int8, uint8 }"
 
+#define GST_TENSOR_CAP_DEFAULT \
+    "other/tensor, " \
+    "framerate = " GST_TENSOR_RATE_RANGE
+    /* "framerate = " GST_TENSOR_RATE_RANGE ", " \     */
+    /* "type = (string) ANY, "\ */
+    /* "dimension = (string) ANY" */
+
+    /**
+     * type should be one of types in GST_TENSOR_TYPE_ALL
+     * "type = (string) uint8"
+     * dimension shoule be a formatted string with rank NNS_TENSOR_RANK_LIMIT
+     * "dimension = (string) dim1:dim2:dim3:dim4"
+     */
+
+/**
+ * @brief This value, 16, can be checked with gst_buffer_get_max_memory(),
+ * which is GST_BUFFER_MEM_MAX in gstreamer/gstbuffer.c.
+ * We redefined the value because GST_BUFFER_MEM_MAX is not exported and
+ * we need static value. To modify (increase) this value, you need to update
+ * gstreamer/gstbuffer.c as well.
+ */
+#define GST_TENSOR_NUM_TENSORS_RANGE "(int) [ 1, " NNS_TENSOR_SIZE_LIMIT_STR " ]"
+
+/**
+ * @brief Default static capibility for other/tensors
+ *
+ * This type uses GstMetaTensor to describe tensor. So there is no need to ask information
+ * to identify each tensor.
+ *
+ */
+#define GST_TENSORS_CAP_DEFAULT \
+    "other/tensors, " \
+    "num_tensors = " GST_TENSOR_NUM_TENSORS_RANGE ", "\
+    "framerate = " GST_TENSOR_RATE_RANGE
+    /* "framerate = " GST_TENSOR_RATE_RANGE ", "\ */
+    /* "types = (string) ANY, "\ */
+    /* "dimensions = (string) ANY" */
+
+    /**
+     * type should be one of types in GST_TENSOR_TYPE_ALL
+     * "types = (string) uint8, uint8, uint8"
+     * Dimensions of Tensors for negotiation. It's comment out here,
+       but when we call gst_structure_get_string, it actually is working well
+     * "dimensions = (string) dim1:dim2:dim3:dim4, dim1:dim2:dim3:dim4"
+     */
+
+/**
+ * @brief Possible input stream types for other/tensor.
+ *
+ * This is realted with media input stream to other/tensor.
+ * There is no restrictions for the outputs.
+ */
+typedef enum _nns_media_type
+{
+  _NNS_VIDEO = 0, /**< supposedly video/x-raw */
+  _NNS_AUDIO, /**< supposedly audio/x-raw */
+  _NNS_STRING, /**< supposedly text/x-raw */
+  _NNS_OCTET, /**< supposedly application/octet-stream */
+
+  _NNS_MEDIA_END, /**< End Marker */
+} media_type;
+
+/**
+ * @brief Internal data structure for configured tensor info (for other/tensor).
+ */
+typedef struct
+{
+  GstTensorInfo info; /**< tensor info*/
+  gint rate_n; /**< framerate is in fraction, which is numerator/denominator */
+  gint rate_d; /**< framerate is in fraction, which is numerator/denominator */
+} GstTensorConfig;
+
+/**
+ * @brief Internal data structure for configured tensors info (for other/tensors).
+ */
+typedef struct
+{
+  GstTensorsInfo info; /**< tensor info*/
+  gint rate_n; /**< framerate is in fraction, which is numerator/denominator */
+  gint rate_d; /**< framerate is in fraction, which is numerator/denominator */
+} GstTensorsConfig;
+
 /**
  * @brief time synchronization options
  */
@@ -126,6 +214,42 @@ typedef struct
 } GstTensorCollectPadData;
 
 /**
+ * @brief String representations for each tensor element type.
+ */
+extern const gchar *tensor_element_typename[];
+
+/**
+ * @brief Get media type from caps
+ * @param caps caps to be interpreted
+ * @return corresponding media type (returns _NNS_MEDIA_END for unsupported type)
+ */
+extern media_type
+gst_tensor_media_type_from_caps (const GstCaps * caps);
+
+/**
+ * @brief Get media type from structure
+ * @param structure structure to be interpreted
+ * @return corresponding media type (returns _NNS_MEDIA_END for unsupported type)
+ */
+extern media_type
+gst_tensor_media_type_from_structure (const GstStructure * structure);
+
+/**
+ * @brief Initialize the tensor info structure
+ * @param info tensor info structure to be initialized
+ */
+extern void
+gst_tensor_info_init (GstTensorInfo * info);
+
+/**
+ * @brief Check the tensor info is valid
+ * @param info tensor info structure
+ * @return TRUE if info is valid
+ */
+extern gboolean
+gst_tensor_info_validate (const GstTensorInfo * info);
+
+/**
  * @brief Compare tensor info
  * @param TRUE if equal
  */
@@ -133,11 +257,27 @@ extern gboolean
 gst_tensor_info_is_equal (const GstTensorInfo * i1, const GstTensorInfo * i2);
 
 /**
- * @brief Copy tensor info
- * @note GstTensorInfo::name should be freed with g_free()
+ * @brief Get data size of single tensor
+ * @param info tensor info structure
+ * @return data size
+ */
+extern gsize
+gst_tensor_info_get_size (const GstTensorInfo * info);
+
+/**
+ * @brief Initialize the tensors info structure
+ * @param info tensors info structure to be initialized
  */
 extern void
-gst_tensor_info_copy (GstTensorInfo * dest, const GstTensorInfo * src);
+gst_tensors_info_init (GstTensorsInfo * info);
+
+/**
+ * @brief Check the tensors info is valid
+ * @param info tensors info structure
+ * @return TRUE if info is valid
+ */
+extern gboolean
+gst_tensors_info_validate (const GstTensorsInfo * info);
 
 /**
  * @brief Compare tensors info
@@ -147,11 +287,22 @@ extern gboolean
 gst_tensors_info_is_equal (const GstTensorsInfo * i1, const GstTensorsInfo * i2);
 
 /**
- * @brief Copy tensor info
- * @note GstTensorInfo::name should be freed with g_free()
+ * @brief Parse the string of dimensions
+ * @param info tensors info structure
+ * @param dim_string string of dimensions
+ * @return number of parsed dimensions
  */
-extern void
-gst_tensors_info_copy (GstTensorsInfo * dest, const GstTensorsInfo * src);
+extern guint
+gst_tensors_info_parse_dimensions_string (GstTensorsInfo * info, const gchar * dim_string);
+
+/**
+ * @brief Parse the string of types
+ * @param info tensors info structure
+ * @param type_string string of types
+ * @return number of parsed types
+ */
+extern guint
+gst_tensors_info_parse_types_string (GstTensorsInfo * info, const gchar * type_string);
 
 /**
  * @brief Parse the string of names
@@ -190,6 +341,21 @@ extern gchar *
 gst_tensors_info_get_names_string (const GstTensorsInfo * info);
 
 /**
+ * @brief Initialize the tensor config info structure
+ * @param config tensor config structure to be initialized
+ */
+extern void
+gst_tensor_config_init (GstTensorConfig * config);
+
+/**
+ * @brief Check the tensor is all configured
+ * @param config tensor config structure
+ * @return TRUE if configured
+ */
+extern gboolean
+gst_tensor_config_validate (const GstTensorConfig * config);
+
+/**
  * @brief Compare tensor config info
  * @param TRUE if equal
  */
@@ -198,6 +364,17 @@ gst_tensor_config_is_equal (const GstTensorConfig * c1,
     const GstTensorConfig * c2);
 
 /**
+ * @brief Parse structure and set tensor config info (for other/tensor)
+ * @param config tensor config structure to be filled
+ * @param structure structure to be interpreted
+ * @note Change dimention if tensor contains N frames.
+ * @return TRUE if no error
+ */
+extern gboolean
+gst_tensor_config_from_structure (GstTensorConfig * config,
+    const GstStructure * structure);
+
+/**
  * @brief Get tensor caps from tensor config (for other/tensor)
  * @param config tensor config info
  * @return caps for given config
@@ -206,6 +383,21 @@ extern GstCaps *
 gst_tensor_caps_from_config (const GstTensorConfig * config);
 
 /**
+ * @brief Initialize the tensors config info structure (for other/tensors)
+ * @param config tensors config structure to be initialized
+ */
+extern void
+gst_tensors_config_init (GstTensorsConfig * config);
+
+/**
+ * @brief Check the tensors are all configured (for other/tensors)
+ * @param config tensor config structure
+ * @return TRUE if configured
+ */
+extern gboolean
+gst_tensors_config_validate (const GstTensorsConfig * config);
+
+/**
  * @brief Compare tensor config info (for other/tensors)
  * @param TRUE if equal
  */
@@ -214,6 +406,16 @@ gst_tensors_config_is_equal (const GstTensorsConfig * c1,
     const GstTensorsConfig * c2);
 
 /**
+ * @brief Parse structure and set tensors config (for other/tensors)
+ * @param config tensors config structure to be filled
+ * @param structure structure to be interpreted
+ * @return TRUE if no error
+ */
+extern gboolean
+gst_tensors_config_from_structure (GstTensorsConfig * config,
+    const GstStructure * structure);
+
+/**
  * @brief Get caps from tensors config (for other/tensors)
  * @param config tensors config info
  * @return caps for given config
@@ -222,6 +424,13 @@ extern GstCaps *
 gst_tensors_caps_from_config (const GstTensorsConfig * config);
 
 /**
+ * @brief Get tensor_type from string tensor_type input
+ * @return Corresponding tensor_type. _NNS_END if unrecognized value is there.
+ * @param typestr The string type name, supposed to be one of tensor_element_typename[]
+ */
+extern tensor_type get_tensor_type (const gchar * typestr);
+
+/**
  * @brief Find the index value of the given key string array
  * @return Corresponding index
  * @param strv Null terminated array of gchar *
@@ -230,6 +439,37 @@ gst_tensors_caps_from_config (const GstTensorsConfig * config);
 extern int find_key_strv (const gchar ** strv, const gchar * key);
 
 /**
+ * @brief Check the tensor dimension is valid
+ * @param dim tensor dimension
+ * @return TRUE if dimension is valid
+ */
+extern gboolean
+gst_tensor_dimension_is_valid (const tensor_dim dim);
+
+/**
+ * @brief Parse tensor dimension parameter string
+ * @return The Rank. 0 if error.
+ * @param dimstr The dimension string in the format of d1:d2:d3:d4, d1:d2:d3, d1:d2, or d1, where dN is a positive integer and d1 is the innermost dimension; i.e., dim[d4][d3][d2][d1];
+ * @param dim dimension to be filled.
+ */
+extern int get_tensor_dimension (const gchar * dimstr, tensor_dim dim);
+
+/**
+ * @brief Get dimension string from given tensor dimension.
+ * @param dim tensor dimension
+ * @return Formatted string of given dimension (d1:d2:d3:d4).
+ * @note The returned value should be freed with g_free()
+ */
+extern gchar *get_tensor_dimension_string (const tensor_dim dim);
+
+/**
+ * @brief Count the number of elemnts of a tensor
+ * @return The number of elements. 0 if error.
+ * @param dim The tensor dimension
+ */
+extern size_t get_tensor_element_count (const tensor_dim dim);
+
+/**
  * @brief A callback for typefind, trying to find whether a file is other/tensors or not.
  * For the concrete definition of headers, please look at the wiki page of nnstreamer:
  * https://github.com/nnsuite/nnstreamer/wiki/Design-External-Save-Format-for-other-tensor-and-other-tensors-Stream-for-TypeFind
diff --git a/gst/nnstreamer/tensor_converter/tensor_converter.c b/gst/nnstreamer/tensor_converter/tensor_converter.c
index b3628ae..d08b5ab 100644
--- a/gst/nnstreamer/tensor_converter/tensor_converter.c
+++ b/gst/nnstreamer/tensor_converter/tensor_converter.c
@@ -48,10 +48,10 @@
 /**
  * @brief Macro for debug mode.
  */
-#ifndef DBG
-#define DBG (!self->silent)
-#endif
-
+/* #ifndef DBG */
+/* #define DBG (!self->silent) */
+/* #endif */
+#define DBG TRUE
 /**
  * @brief Macro for debug message.
  */
diff --git a/gst/nnstreamer/tensor_decoder/tensordec-boundingbox.c b/gst/nnstreamer/tensor_decoder/tensordec-boundingbox.c
index 1cd6184..ee1f4cc 100644
--- a/gst/nnstreamer/tensor_decoder/tensordec-boundingbox.c
+++ b/gst/nnstreamer/tensor_decoder/tensordec-boundingbox.c
@@ -60,9 +60,6 @@
 
 #define BOX_SIZE                  4
 #define TFLITE_SSD_DETECTION_MAX  1917
-#define TFLITE_SSD_MAX_TENSORS    2
-#define TF_SSD_DETECTION_MAX      100
-#define TF_SSD_MAX_TENSORS        4
 #define PIXEL_VALUE               (0xFF0000FF)  /* RED 100% in RGBA */
 
 /**
@@ -92,7 +89,7 @@ static const gchar *bb_modes[] = {
 };
 
 /**
- * @brief Data structure for SSD boundig box info for tf-lite ssd model.
+ * @brief Data structure for SSD boundig box info.
  */
 typedef struct
 {
@@ -137,8 +134,6 @@ _init_modes (bounding_boxes * bdata)
   if (bdata->mode == TFLITE_SSD_BOUNDING_BOX) {
     /* properties_TFLite_SSD *data = &bdata->tflite-ssd; */
     return TRUE;
-  } else if (bdata->mode == TF_SSD_BOUNDING_BOX) {
-    return TRUE;
   }
   return TRUE;
 }
@@ -154,10 +149,10 @@ bb_init (GstTensorDec * self)
 
   bdata = self->plugin_data;
   bdata->mode = BOUNDING_BOX_UNKNOWN;
-  bdata->width = 0;
-  bdata->height = 0;
-  bdata->i_width = 0;
-  bdata->i_height = 0;
+  bdata->width = 640;
+  bdata->height = 480;
+  bdata->i_width = 300;
+  bdata->i_height = 300;
 
   /** @todo Constify singleLineSprite and remove this loop */
   for (i = 0; i < 256; i++) {
@@ -192,7 +187,6 @@ _exit_modes (bounding_boxes * bdata)
 {
   if (bdata->mode == TFLITE_SSD_BOUNDING_BOX) {
     /* properties_TFLite_SSD *data = &bdata->tflite_ssd; */
-  } else if (bdata->mode == TF_SSD_BOUNDING_BOX) {
   }
 }
 
@@ -402,64 +396,12 @@ bb_setOption (GstTensorDec * self, int opNum, const gchar * param)
 }
 
 /**
- * @brief check the num_tensors is valid
-*/
-static gboolean
-_check_tensors (const GstTensorsConfig * config, const int limit)
-{
-  int i;
-  g_return_val_if_fail (config != NULL, FALSE);
-  g_return_val_if_fail (config->info.num_tensors >= limit, FALSE);
-  if (config->info.num_tensors > limit) {
-    GST_WARNING ("tensor-decoder:boundingbox accepts %d or less tensors. "
-        "You are wasting the bandwidth by supplying %d tensors.",
-        limit, config->info.num_tensors);
-  }
-
-  /* tensor-type of the tensors shoule be the same */
-  for (i = 1; i < config->info.num_tensors; ++i) {
-    g_return_val_if_fail (config->info.info[i - 1].type ==
-        config->info.info[i].type, FALSE);
-  }
-  return TRUE;
-}
-
-/**
- * @brief set the max_detection
-*/
-static gboolean
-_set_max_detection (bounding_boxes * data, const guint max_detection,
-    const int limit)
-{
-  /* Check consistency with max_detection */
-  if (data->max_detection == 0)
-    data->max_detection = max_detection;
-  else
-    g_return_val_if_fail (max_detection == data->max_detection, FALSE);
-
-  if (data->max_detection > limit) {
-    GST_ERROR
-        ("Incoming tensor has too large detection-max : %u", max_detection);
-    return FALSE;
-  }
-  return TRUE;
-}
-
-/**
  * @brief tensordec-plugin's TensorDecDef callback
  *
- * [TF-Lite SSD Model]
  * The first tensor is boxes. BOX_SIZE : 1 : #MaxDetection, ANY-TYPE
  * The second tensor is labels. #MaxLabel : #MaxDetection, ANY-TYPE
  * Both tensors are MANDATORY!
  *
- * [Tensorflow SSD Model]
- * The first tensor is num_detection. 1, ANY-TYPE
- * The second tensor is detection_classes. #MaxDetection, ANY-TYPE
- * The third tensor is detection_scores. #MaxDetection, ANY-TYPE
- * The fourth tensor is detection_boxes. BOX_SIZE : #MaxDetection, ANY-TYPE
- * all of tensors are MANDATORY!
- *
  * If there are third or more tensors, such tensors will be ignored.
  */
 static GstCaps *
@@ -468,72 +410,54 @@ bb_getOutCaps (GstTensorDec * self, const GstTensorsConfig * config)
   /** @todo this is compatible with "SSD" only. expand the capability! */
   bounding_boxes *data = self->plugin_data;
   GstCaps *caps;
+  const uint32_t *dim1, *dim2;
   int i;
   gchar *str;
   guint max_detection, max_label;
 
-  if (data->mode == TFLITE_SSD_BOUNDING_BOX) {
-    const uint32_t *dim1, *dim2;
-    if (!_check_tensors (config, TFLITE_SSD_MAX_TENSORS))
-      return NULL;
-
-    /* Check if the first tensor is compatible */
-    dim1 = config->info.info[0].dimension;
-    g_return_val_if_fail (dim1[0] == BOX_SIZE, NULL);
-    g_return_val_if_fail (dim1[1] == 1, NULL);
-    max_detection = dim1[2];
-    g_return_val_if_fail (max_detection > 0, NULL);
-    for (i = 3; i < NNS_TENSOR_RANK_LIMIT; i++)
-      g_return_val_if_fail (dim1[i] == 1, NULL);
-
-    /* Check if the second tensor is compatible */
-    dim2 = config->info.info[1].dimension;
-    max_label = dim2[0];
-    g_return_val_if_fail (max_label <= data->total_labels, NULL);
-    if (max_label < data->total_labels)
-      GST_WARNING
-          ("The given tensor (2nd) has max_label (first dimension: %u) smaller than the number of labels in labels file (%s: %u).",
-          max_label, data->label_path, data->total_labels);
-    g_return_val_if_fail (max_detection == dim2[1], NULL);
-    for (i = 2; i < NNS_TENSOR_RANK_LIMIT; i++)
-      g_return_val_if_fail (dim2[i] == 1, NULL);
-
-    /* Check consistency with max_detection */
-    if (!_set_max_detection (data, max_detection, TFLITE_SSD_DETECTION_MAX)) {
-      return NULL;
-    }
-  } else if (data->mode == TF_SSD_BOUNDING_BOX) {
-    const uint32_t *dim1, *dim2, *dim3, *dim4;
-    if (!_check_tensors (config, TF_SSD_MAX_TENSORS))
-      return NULL;
-
-    /* Check if the first tensor is compatible */
-    dim1 = config->info.info[0].dimension;
-    g_return_val_if_fail (dim1[0] == 1, NULL);
-    for (i = 1; i < NNS_TENSOR_RANK_LIMIT; ++i)
-      g_return_val_if_fail (dim1[i] == 1, NULL);
-
-    /* Check if the second & third tensor is compatible */
-    dim2 = config->info.info[1].dimension;
-    dim3 = config->info.info[2].dimension;
-    g_return_val_if_fail (dim3[0] == dim2[0], NULL);
-    max_detection = dim2[0];
-    for (i = 1; i < NNS_TENSOR_RANK_LIMIT; ++i) {
-      g_return_val_if_fail (dim2[i] == 1, NULL);
-      g_return_val_if_fail (dim3[i] == 1, NULL);
-    }
+  g_return_val_if_fail (config != NULL, NULL);
+  g_return_val_if_fail (config->info.num_tensors >= 2, NULL);
+  if (config->info.num_tensors > 2) {
+    GST_WARNING ("tensor-decoder:boundingbox accepts 1 or 2 tensors. "
+        "You are wasting the bandwidth by supplying %d tensors.",
+        config->info.num_tensors);
+  }
 
-    /* Check if the fourth tensor is compatible */
-    dim4 = config->info.info[3].dimension;
-    g_return_val_if_fail (BOX_SIZE == dim4[0], NULL);
-    g_return_val_if_fail (max_detection == dim4[1], NULL);
-    for (i = 2; i < NNS_TENSOR_RANK_LIMIT; ++i)
-      g_return_val_if_fail (dim4[i] == 1, NULL);
+  /* Check if the first tensor is compatible */
+  dim1 = config->info.info[0].dimension;
+  g_return_val_if_fail (dim1[0] == BOX_SIZE, NULL);
+  g_return_val_if_fail (dim1[1] == 1, NULL);
+  max_detection = dim1[2];
+  g_return_val_if_fail (max_detection > 0, NULL);
+  for (i = 3; i < NNS_TENSOR_RANK_LIMIT; i++)
+    g_return_val_if_fail (dim1[i] == 1, NULL);
+
+  /* Check if the second tensor is compatible */
+  dim2 = config->info.info[1].dimension;
+  max_label = dim2[0];
+  g_return_val_if_fail (max_label <= data->total_labels, NULL);
+  if (max_label < data->total_labels)
+    GST_WARNING
+        ("The given tensor (2nd) has max_label (first dimension: %u) smaller than the number of labels in labels file (%s: %u).",
+        max_label, data->label_path, data->total_labels);
+  g_return_val_if_fail (max_detection == dim2[1], NULL);
+  for (i = 2; i < NNS_TENSOR_RANK_LIMIT; i++)
+    g_return_val_if_fail (dim2[i] == 1, NULL);
+
+  /* tensor-type of the two tensors shoule be the same */
+  g_return_val_if_fail (config->info.info[0].type == config->info.info[1].type,
+      NULL);
 
-    /* Check consistency with max_detection */
-    if (!_set_max_detection (data, max_detection, TF_SSD_DETECTION_MAX)) {
-      return NULL;
-    }
+  /* Check consistency with max_detection */
+  if (data->max_detection == 0)
+    data->max_detection = max_detection;
+  else
+    g_return_val_if_fail (max_detection == data->max_detection, NULL);
+  if (data->max_detection > TFLITE_SSD_DETECTION_MAX) {
+    GST_ERROR
+        ("Incoming tensor has too large detection-max (3rd rank in tensor_0 and 2nd rank in tensor_1) : %u",
+        max_detection);
+    return NULL;
   }
 
   str = g_strdup_printf ("video/x-raw, format = RGBA, " /* Use alpha channel to make the background transparent */
@@ -652,7 +576,7 @@ typedef struct
  * @param[in] detinputptr Cursor pointer of input + byte-per-index * index (detection)
  * @param[in] result The object returned. (pointer to object)
  */
-#define _get_object_i_tflite(bb, index, boxprior, boxinputptr, detinputptr, result) \
+#define _get_object_i(bb, index, boxprior, boxinputptr, detinputptr, result) \
   do { \
     int c; \
     for (c = 1; c < bb->total_labels; c++) { \
@@ -678,20 +602,21 @@ typedef struct
         break; \
       } \
     } \
-  } while (0);
+   } while (0);
 
 /**
- * @brief C++-Template-like box location calculation for box-priors for TF-Lite SSD Model
+ * @brief C++-Template-like box location calculation for box-priors
  * @param[in] bb The configuration, "bounding_boxes"
  * @param[in] type The tensor type of inputptr
  * @param[in] typename nnstreamer enum corresponding to the type
+ * @param[in] index The index (3rd dimension of BOX_SIZE:1:TFLITE_SSD_DETECTION_MAX:1)
  * @param[in] boxprior The box prior data from the box file of TFLITE_SSD.
  * @param[in] boxinput Input Tensor Data (Boxes)
  * @param[in] detinput Input Tensor Data (Detection). Null if not available. (numtensor ==1)
  * @param[in] config Tensor configs of the input tensors
  * @param[out] results The object returned. (GArray with detectedObject)
  */
-#define _get_objects_tflite(bb, _type, typename, boxprior, boxinput, detinput, config, results) \
+#define _get_objects(bb, _type, typename, boxprior, boxinput, detinput, config, results) \
   case typename: \
   { \
     int d; \
@@ -700,9 +625,9 @@ typedef struct
     _type * detinput_ = (_type *) detinput; \
     gsize detbpi = config->info.info[1].dimension[0]; \
     int num = (TFLITE_SSD_DETECTION_MAX > bb->max_detection) ? bb->max_detection : TFLITE_SSD_DETECTION_MAX; \
-    detectedObject object = { .valid = FALSE, .class_id = 0, .x = 0, .y = 0, .width = 0, .height = 0, .prob = .0 }; \
+    detectedObject object = { .valid = FALSE, .class_id = 0, .x = 0, .y = 0, .width = 0, .height = 0, .prob = 0 }; \
     for (d = 0; d < num; d++) { \
-      _get_object_i_tflite (bb, d, boxprior, (boxinput_ + (d * boxbpi)), (detinput_ + (d * detbpi)), (&object)); \
+      _get_object_i (bb, d, boxprior, (boxinput_ + (d * boxbpi)), (detinput_ + (d * detbpi)), (&object)); \
       if (object.valid == TRUE) { \
         g_array_append_val (results, object); \
       } \
@@ -710,9 +635,10 @@ typedef struct
   } \
   break
 
-/** @brief Macro to simplify calling _get_objects_tflite */
-#define _get_objects_tflite_(type, typename) \
-  _get_objects_tflite (bdata, type, typename, (bdata->tflite_ssd.box_priors), (boxes->data), (detections->data), config, results)
+/** @brief Macro to simplify calling _get_objects */
+#define _get_objects_(type, typename) \
+  _get_objects (bdata, type, typename, (bdata->tflite_ssd.box_priors), (boxes->data), (detections->data), config, results)
+
 
 /**
  * @brief Compare Function for g_array_sort with detectedObject.
@@ -786,48 +712,6 @@ nms (GArray * results)
 }
 
 /**
- * @brief C++-Template-like box location calculation for Tensorflow SSD model
- * @param[in] bb The configuration, "bounding_boxes"
- * @param[in] type The tensor type of inputptr
- * @param[in] typename nnstreamer enum corresponding to the type
- * @param[in] numinput Input Tensor Data (The number of detections)
- * @param[in] classinput Input Tensor Data (Detected classes)
- * @param[in] scoreinput Input Tensor Data (Detection scores)
- * @param[in] boxesinput Input Tensor Data (Boxes)
- * @param[in] config Tensor configs of the input tensors
- * @param[out] results The object returned. (GArray with detectedObject)
- */
-#define _get_objects_tf(bb, _type, typename, numinput, classinput, scoreinput, boxesinput, config, results) \
-  case typename: \
-  { \
-    int d; \
-    _type * num_detection_ = (_type *) numinput; \
-    _type * classes_ = (_type *) classinput; \
-    _type * scores_ = (_type *) scoreinput; \
-    _type * boxes_ = (_type *) boxesinput; \
-    int num = (int) num_detection_[0]; \
-    results = g_array_sized_new (FALSE, TRUE, sizeof (detectedObject), num); \
-    gsize boxbpi = config->info.info[3].dimension[0]; \
-    for (d = 0; d < num; d++) { \
-      detectedObject object; \
-      object.valid = TRUE; \
-      object.class_id = (int) classes_[d]; \
-      object.x = (int) (boxes_[d * boxbpi + 1] * bb->width); \
-      object.y = (int) (boxes_[d * boxbpi] * bb->height); \
-      object.width = (int) ((boxes_[d * boxbpi + 3] - boxes_[d * boxbpi + 1]) * bb->width); \
-      object.height = (int) ((boxes_[d * boxbpi + 2] - boxes_[d * boxbpi]) * bb->height); \
-      object.prob = scores_[d]; \
-      g_array_append_val (results, object); \
-    } \
-  } \
-  break
-
-/** @brief Macro to simplify calling _get_objects_tf */
-#define _get_objects_tf_(type, typename) \
-  _get_objects_tf (bdata, type, typename, (mem_num->data), (mem_classes->data), (mem_scores->data), (mem_boxes->data), config, results)
-
-
-/**
  * @brief Draw with the given results (obejcts[TFLITE_SSD_DETECTION_MAX]) to the output buffer
  * @param[out] out_info The output buffer (RGBA plain)
  * @param[in] bdata The bouding-box internal data.
@@ -911,11 +795,25 @@ bb_decode (GstTensorDec * self, const GstTensorMemory * input,
   const gsize size = bdata->width * bdata->height * 4;  /* RGBA */
   GstMapInfo out_info;
   GstMemory *out_mem;
-  GArray *results = NULL;
   const GstTensorsConfig *config = &self->tensor_config;
+
   const int num_tensors = config->info.num_tensors;
+  const GstTensorMemory *boxes, *detections = NULL;
+  GArray *results =
+      g_array_sized_new (FALSE, TRUE, sizeof (detectedObject), 100);
+  /**
+   * @todo 100 is a heuristic number of objects in a picture frame
+   *       We may have better "heuristics" than this.
+   *       For the sake of performance, don't make it too small.
+   */
 
   g_assert (outbuf);
+  g_assert (num_tensors >= 2);
+
+  boxes = &input[0];
+  if (num_tensors >= 2)
+    detections = &input[1];
+
   /* Ensure we have outbuf properly allocated */
   if (gst_buffer_get_size (outbuf) == 0) {
     out_mem = gst_allocator_alloc (NULL, size, NULL);
@@ -930,65 +828,22 @@ bb_decode (GstTensorDec * self, const GstTensorMemory * input,
   /** reset the buffer with alpha 0 / black */
   memset (out_info.data, 0, size);
 
-  if (bdata->mode == TFLITE_SSD_BOUNDING_BOX) {
-    const GstTensorMemory *boxes, *detections = NULL;
-    results = g_array_sized_new (FALSE, TRUE, sizeof (detectedObject), 100);
-    /**
-     * @todo 100 is a heuristic number of objects in a picture frame
-     *       We may have better "heuristics" than this.
-     *       For the sake of performance, don't make it too small.
-     */
-
-    g_assert (num_tensors >= TFLITE_SSD_MAX_TENSORS);
-
-    boxes = &input[0];
-    if (num_tensors >= TFLITE_SSD_MAX_TENSORS)
-      detections = &input[1];
-
-    switch (config->info.info[0].type) {
-        _get_objects_tflite_ (uint8_t, _NNS_UINT8);
-        _get_objects_tflite_ (int8_t, _NNS_INT8);
-        _get_objects_tflite_ (uint16_t, _NNS_UINT16);
-        _get_objects_tflite_ (int16_t, _NNS_INT16);
-        _get_objects_tflite_ (uint32_t, _NNS_UINT32);
-        _get_objects_tflite_ (int32_t, _NNS_INT32);
-        _get_objects_tflite_ (uint64_t, _NNS_UINT64);
-        _get_objects_tflite_ (int64_t, _NNS_INT64);
-        _get_objects_tflite_ (float, _NNS_FLOAT32);
-        _get_objects_tflite_ (double, _NNS_FLOAT64);
-      default:
-        g_assert (0);
-    }
-    nms (results);
-  } else if (bdata->mode == TF_SSD_BOUNDING_BOX) {
-    const GstTensorMemory *mem_num, *mem_classes, *mem_scores, *mem_boxes;
-    results =
-        g_array_sized_new (FALSE, TRUE, sizeof (detectedObject),
-        TF_SSD_DETECTION_MAX);
-
-    g_assert (num_tensors >= TF_SSD_MAX_TENSORS);
-
-    mem_num = &input[0];
-    mem_classes = &input[1];
-    mem_scores = &input[2];
-    mem_boxes = &input[3];
-
-    switch (config->info.info[0].type) {
-        _get_objects_tf_ (uint8_t, _NNS_UINT8);
-        _get_objects_tf_ (int8_t, _NNS_INT8);
-        _get_objects_tf_ (uint16_t, _NNS_UINT16);
-        _get_objects_tf_ (int16_t, _NNS_INT16);
-        _get_objects_tf_ (uint32_t, _NNS_UINT32);
-        _get_objects_tf_ (int32_t, _NNS_INT32);
-        _get_objects_tf_ (uint64_t, _NNS_UINT64);
-        _get_objects_tf_ (int64_t, _NNS_INT64);
-        _get_objects_tf_ (float, _NNS_FLOAT32);
-        _get_objects_tf_ (double, _NNS_FLOAT64);
-      default:
-        g_assert (0);
-    }
+  switch (config->info.info[0].type) {
+      _get_objects_ (uint8_t, _NNS_UINT8);
+      _get_objects_ (int8_t, _NNS_INT8);
+      _get_objects_ (uint16_t, _NNS_UINT16);
+      _get_objects_ (int16_t, _NNS_INT16);
+      _get_objects_ (uint32_t, _NNS_UINT32);
+      _get_objects_ (int32_t, _NNS_INT32);
+      _get_objects_ (uint64_t, _NNS_UINT64);
+      _get_objects_ (int64_t, _NNS_INT64);
+      _get_objects_ (float, _NNS_FLOAT32);
+      _get_objects_ (double, _NNS_FLOAT64);
+    default:
+      g_assert (0);
   }
 
+  nms (results);
   draw (&out_info, bdata, results);
   g_array_free (results, TRUE);
 
diff --git a/gst/nnstreamer/tensor_decoder/tensordec-plugins.c b/gst/nnstreamer/tensor_decoder/tensordec-plugins.c
index f299ca6..1886fe4 100644
--- a/gst/nnstreamer/tensor_decoder/tensordec-plugins.c
+++ b/gst/nnstreamer/tensor_decoder/tensordec-plugins.c
@@ -82,8 +82,6 @@ tensordec_probe (TensorDecDef * decoder)
   GST_INFO ("A new subplugin, \"%s\" is registered for tensor_decoder.\n",
       decoder->modename);
 
-  /** @todo @buf unregister at exit */
-  hold_register_subplugin (NNS_SUBPLUGIN_DECODER, decoder->modename, decoder);
   return TRUE;
 }
 
diff --git a/gst/nnstreamer/tensor_filter/meson.build b/gst/nnstreamer/tensor_filter/meson.build
index 5e3a8cd..d52bce7 100644
--- a/gst/nnstreamer/tensor_filter/meson.build
+++ b/gst/nnstreamer/tensor_filter/meson.build
@@ -6,7 +6,7 @@ tensor_filter_sources = [
 if have_tensorflow
   tensor_filter_sources += ['tensor_filter_tensorflow.c']
 
-  tensor_filter_tfcore_lib_shared = shared_library('tensor_filter_tensorflow',
+  tensor_filter_tfcore_lib_shared = shared_library('tensor_filter_tfcore',
     ['tensor_filter_tensorflow_core.cc'],
     cpp_args: ['-Wno-sign-compare'],
     dependencies: [tf_dep, protobuf_dep, glib_dep, gst_dep],
@@ -15,7 +15,7 @@ if have_tensorflow
     install_dir: subplugins_install_dir
   )
 
-  tensor_filter_tfcore_lib_static = static_library('tensor_filter_tensorflow',
+  tensor_filter_tfcore_lib_static = static_library('tensor_filter_tfcore',
     ['tensor_filter_tensorflow_core.cc'],
     cpp_args: ['-Wno-sign-compare'],
     dependencies: [tf_dep, protobuf_dep, glib_dep, gst_dep],
@@ -36,7 +36,7 @@ endif
 if have_tensorflow_lite
   tensor_filter_sources += ['tensor_filter_tensorflow_lite.c']
 
-  tensor_filter_tflitecore_lib_shared = shared_library('tensor_filter_tensorflow-lite',
+  tensor_filter_tflitecore_lib_shared = shared_library('tensor_filter_tflitecore',
     ['tensor_filter_tensorflow_lite_core.cc'],
     cpp_args: ['-Wno-sign-compare'],
     dependencies: [tflite_dep, thread_dep, libdl_dep, glib_dep, gst_dep],
@@ -45,7 +45,7 @@ if have_tensorflow_lite
     install_dir: subplugins_install_dir
   )
 
-  tensor_filter_tflitecore_lib_static = static_library('tensor_filter_tensorflow-lite',
+  tensor_filter_tflitecore_lib_static = static_library('tensor_filter_tflitecore',
     ['tensor_filter_tensorflow_lite_core.cc'],
     cpp_args: ['-Wno-sign-compare'],
     dependencies: [tflite_dep, thread_dep, libdl_dep, glib_dep, gst_dep],
diff --git a/gst/nnstreamer/tensor_filter/tensor_filter.c b/gst/nnstreamer/tensor_filter/tensor_filter.c
index 4bfd717..86a4630 100644
--- a/gst/nnstreamer/tensor_filter/tensor_filter.c
+++ b/gst/nnstreamer/tensor_filter/tensor_filter.c
@@ -108,7 +108,6 @@
   } \
 } while (0)
 
-#define g_free_const(x) g_free((void*)(long)(x))
 
 typedef struct _TensorFilterSPList TensorFilterSPList;
 /**
@@ -158,10 +157,6 @@ tensor_filter_probe (GstTensorFilterFramework * tfsp)
 
   GST_INFO ("A new sub-plugin, \"%s\" is registered for tensor_filter.\n",
       tfsp->name);
-
-  /** @todo @bug unregister at exit */
-  hold_register_subplugin (NNS_SUBPLUGIN_FILTER, tfsp->name, tfsp);
-
   return TRUE;
 }
 
@@ -273,7 +268,6 @@ static void gst_tensor_filter_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * pspec);
 static void gst_tensor_filter_get_property (GObject * object, guint prop_id,
     GValue * value, GParamSpec * pspec);
-static void gst_tensor_filter_finalize (GObject * object);
 
 /* GstBaseTransform vmethod implementations */
 static GstFlowReturn gst_tensor_filter_transform (GstBaseTransform * trans,
@@ -298,7 +292,7 @@ static gboolean gst_tensor_filter_stop (GstBaseTransform * trans);
 #define gst_tensor_filter_open_fw(filter) do { \
       if (filter->prop.fw_opened == FALSE && filter->fw) { \
         if (filter->fw->open != NULL) {\
-          if (filter->fw->open (&filter->prop, &filter->privateData) == 0) \
+          if (filter->fw->open (filter, &filter->privateData) == 0) \
             filter->prop.fw_opened = TRUE; \
         } else {\
           filter->prop.fw_opened = TRUE; \
@@ -312,10 +306,9 @@ static gboolean gst_tensor_filter_stop (GstBaseTransform * trans);
 #define gst_tensor_filter_close_fw(filter) do { \
       if (filter->prop.fw_opened) { \
         if (filter->fw && filter->fw->close) \
-          filter->fw->close (&filter->prop, &filter->privateData); \
+          filter->fw->close (filter, &filter->privateData); \
         filter->prop.fw_opened = FALSE; \
-        g_free_const (filter->prop.fwname); \
-        filter->prop.fwname = NULL; \
+        g_free ((char *) filter->prop.fwname); \
         filter->fw = NULL; \
       } \
     } while (0)
@@ -327,7 +320,7 @@ static gboolean gst_tensor_filter_stop (GstBaseTransform * trans);
       gst_tensor_filter_open_fw (filter); \
       ret = -1; \
       if (filter->prop.fw_opened && filter->fw && filter->fw->funcname) { \
-        ret = filter->fw->funcname (&filter->prop, &filter->privateData, __VA_ARGS__); \
+        ret = filter->fw->funcname (filter, &filter->privateData, __VA_ARGS__); \
       } \
     } while (0)
 
@@ -347,7 +340,6 @@ gst_tensor_filter_class_init (GstTensorFilterClass * klass)
 
   gobject_class->set_property = gst_tensor_filter_set_property;
   gobject_class->get_property = gst_tensor_filter_get_property;
-  gobject_class->finalize = gst_tensor_filter_finalize;
 
   g_object_class_install_property (gobject_class, PROP_SILENT,
       g_param_spec_boolean ("silent", "Silent", "Produce verbose output",
@@ -456,66 +448,6 @@ gst_tensor_filter_init (GstTensorFilter * self)
 }
 
 /**
- * @brief deallocate the name of each GstTensorInfo.
- * @param The GstTensorsInfo object
- */
-static void
-gst_tensor_filter_deallocate_tensor_name (GstTensorsInfo * info)
-{
-  guint i;
-  for (i = 0; i < info->num_tensors; ++i)
-    g_free (info->info[i].name);
-  gst_tensors_info_init (info);
-}
-
-/**
- * @brief Clear and reset data.
- */
-static void
-gst_tensor_filter_reset (GstTensorFilter * self)
-{
-  GstTensorFilterProperties *prop;
-
-  prop = &self->prop;
-
-  gst_tensor_filter_close_fw (self);
-
-  g_free_const (prop->fwname);
-  prop->fwname = NULL;
-
-  g_free_const (prop->model_file);
-  prop->model_file = NULL;
-
-  g_free_const (prop->custom_properties);
-  prop->custom_properties = NULL;
-
-  prop->input_configured = FALSE;
-  gst_tensor_filter_deallocate_tensor_name (&prop->input_meta);
-
-  prop->output_configured = FALSE;
-  gst_tensor_filter_deallocate_tensor_name (&prop->output_meta);
-
-  self->configured = FALSE;
-  gst_tensors_config_init (&self->in_config);
-  gst_tensors_config_init (&self->out_config);
-}
-
-/**
- * @brief Function to finalize instance.
- */
-static void
-gst_tensor_filter_finalize (GObject * object)
-{
-  GstTensorFilter *self;
-
-  self = GST_TENSOR_FILTER (object);
-
-  gst_tensor_filter_reset (self);
-
-  G_OBJECT_CLASS (parent_class)->finalize (object);
-}
-
-/**
  * @brief Calculate output buffer size.
  * @param self "this" pointer
  * @param index index of output tensors (if index < 0, the size of all output tensors will be returned.)
@@ -583,7 +515,7 @@ gst_tensor_filter_set_property (GObject * object, guint prop_id,
         break;
       }
 
-      g_free_const (prop->fwname);
+      g_free ((char *) prop->fwname);
       prop->fwname = g_strdup (fw_name);
 
       /* See if mandatory methods are filled in */
@@ -598,7 +530,7 @@ gst_tensor_filter_set_property (GObject * object, guint prop_id,
 
       if (prop->model_file) {
         gst_tensor_filter_close_fw (self);
-        g_free_const (prop->model_file);
+        g_free ((char *) prop->model_file);     /* g_free cannot handle const * */
         prop->model_file = NULL;
       }
 
@@ -727,7 +659,7 @@ gst_tensor_filter_set_property (GObject * object, guint prop_id,
       break;
     case PROP_CUSTOM:
       /* In case updated custom properties in runtime! */
-      g_free_const (prop->custom_properties);
+      g_free ((char *) prop->custom_properties);        /* g_free cannot handle const char * */
       prop->custom_properties = g_value_dup_string (value);
       silent_debug ("Custom Option = %s\n", prop->custom_properties);
       break;
@@ -908,8 +840,7 @@ gst_tensor_filter_transform (GstBaseTransform * trans,
 
   /* 3. Call the filter-subplugin callback, "invoke" */
   gst_tensor_filter_call (self, ret, invoke_NN, in_tensors, out_tensors);
-  /** @todo define enum to indicate status code */
-  g_assert (ret >= 0);
+  g_assert (ret == 0);
 
   /* 4. Update result and free map info. */
   for (i = 0; i < prop->output_meta.num_tensors; i++) {
@@ -932,12 +863,6 @@ gst_tensor_filter_transform (GstBaseTransform * trans,
   }
 
   /* 5. Return result! */
-  if (ret > 0) {
-    /** @todo define enum to indicate status code */
-    /* drop this buffer */
-    return GST_BASE_TRANSFORM_FLOW_DROPPED;
-  }
-
   return GST_FLOW_OK;
 unknown_format:
   GST_ELEMENT_ERROR (self, CORE, NOT_IMPLEMENTED, (NULL), ("unknown format"));
@@ -1092,26 +1017,6 @@ _compare_tensors (GstTensorsInfo * info1, GstTensorsInfo * info2)
 }
 
 /**
- * @brief Copy GstTensorsInfo without the name of tensors.
- * @param[out] the destination object
- * @param[in] the source object
- */
-static void
-gst_tensor_filter_copy_info (GstTensorsInfo * dest, const GstTensorsInfo * src)
-{
-  guint i;
-
-  g_return_if_fail (dest != NULL && src != NULL);
-
-  dest->num_tensors = src->num_tensors;
-  for (i = 0; i < src->num_tensors; ++i) {
-    memcpy (dest->info[i].dimension, src->info[i].dimension,
-        sizeof (tensor_dim));
-    dest->info[i].type = src->info[i].type;
-  }
-}
-
-/**
  * @brief Configure input and output tensor info from incaps.
  * @param self "this" pointer
  * @param incaps received caps for sink pad
@@ -1157,7 +1062,7 @@ gst_tensor_filter_configure_tensor (GstTensorFilter * self,
     }
 
     prop->input_configured = TRUE;
-    gst_tensor_filter_copy_info (&prop->input_meta, &in_config.info);
+    prop->input_meta = in_config.info;
 
     /** call setInputDimension if output tensor is not configured */
     if (!prop->output_configured) {
@@ -1181,7 +1086,7 @@ gst_tensor_filter_configure_tensor (GstTensorFilter * self,
         }
 
         prop->output_configured = TRUE;
-        gst_tensor_filter_copy_info (&prop->output_meta, &out_info);
+        prop->output_meta = out_info;
 
         silent_debug_info (&out_info, "output tensor");
       }
diff --git a/gst/nnstreamer/tensor_filter/tensor_filter.h b/gst/nnstreamer/tensor_filter/tensor_filter.h
index 7519a42..acb06df 100644
--- a/gst/nnstreamer/tensor_filter/tensor_filter.h
+++ b/gst/nnstreamer/tensor_filter/tensor_filter.h
@@ -51,6 +51,7 @@ G_BEGIN_DECLS
 
 typedef struct _GstTensorFilter GstTensorFilter;
 typedef struct _GstTensorFilterClass GstTensorFilterClass;
+typedef struct _GstTensorFilterFramework GstTensorFilterFramework;
 
 /**
  * @brief Internal data structure for tensor_filter instances.
@@ -96,6 +97,99 @@ struct _GstTensorFilterClass
  */
 GType gst_tensor_filter_get_type (void);
 
+/**
+ * @brief Subplugin definition
+ *
+ * Common callback parameters:
+ * filter Filter properties. Read Only
+ * private_data Subplugin's private data. Set this (*private_data = XXX) if you want to change filter->private_data
+ */
+struct _GstTensorFilterFramework
+{
+  gchar *name; /**< Name of the neural network framework, searchable by FRAMEWORK property */
+  gboolean allow_in_place; /**< TRUE if InPlace transfer of input-to-output is allowed. Not supported in main, yet */
+  gboolean allocate_in_invoke; /**< TRUE if invoke_NN is going to allocate outputptr by itself and return the address via outputptr. Do not change this value after cap negotiation is complete (or the stream has been started). */
+
+  int (*invoke_NN) (const GstTensorFilter * filter, void **private_data,
+      const GstTensorMemory * input, GstTensorMemory * output);
+      /**< Mandatory callback. Invoke the given network model.
+       *
+       * @param[in] filter "this" pointer. Use this to read property values
+       * @param[in/out] private_data A subplugin may save its internal private data here. The subplugin is responsible for alloc/free of this pointer.
+       * @param[in] input The array of input tensors. Allocated and filled by tensor_filter/main
+       * @param[out] output The array of output tensors. Allocated by tensor_filter/main and to be filled by invoke_NN. If allocate_in_invoke is TRUE, sub-plugin should allocate the memory block for output tensor. (data in GstTensorMemory)
+       * @return 0 if OK. non-zero if error.
+       */
+
+  int (*getInputDimension) (const GstTensorFilter * filter,
+      void **private_data, GstTensorsInfo * info);
+      /**< Optional. Set NULL if not supported. Get dimension of input tensor
+       * If getInputDimension is NULL, setInputDimension must be defined.
+       * If getInputDimension is defined, it is recommended to define getOutputDimension
+       *
+       * @param[in] filter "this" pointer. Use this to read property values
+       * @param[in/out] private_data A subplugin may save its internal private data here. The subplugin is responsible for alloc/free of this pointer.
+       * @param[out] info structure of tensor info (return value)
+       * @return the size of input tensors
+       */
+
+  int (*getOutputDimension) (const GstTensorFilter * filter,
+      void **private_data, GstTensorsInfo * info);
+      /**< Optional. Set NULL if not supported. Get dimension of output tensor
+       * If getInputDimension is NULL, setInputDimension must be defined.
+       * If getInputDimension is defined, it is recommended to define getOutputDimension
+       *
+       * @param[in] filter "this" pointer. Use this to read property values
+       * @param[in/out] private_data A subplugin may save its internal private data here. The subplugin is responsible for alloc/free of this pointer.
+       * @param[out] info structure of tensor info (return value)
+       * @return the size of output tensors
+       */
+
+  int (*setInputDimension) (const GstTensorFilter * filter,
+      void **private_data, const GstTensorsInfo * in_info,
+      GstTensorsInfo * out_info);
+      /**< Optional. Set Null if not supported. Tensor_filter::main will
+       * configure input dimension from pad-cap in run-time for the sub-plugin.
+       * Then, the sub-plugin is required to return corresponding output dimension
+       * If this is NULL, both getInput/OutputDimension must be non-NULL.
+       *
+       * When you use this, do NOT allocate or fix internal data structure based on it
+       * until invoke is called. Gstreamer may try different dimensions before
+       * settling down.
+       *
+       * @param[in] filter "this" pointer. Use this to read property values
+       * @param[in/out] private_data A subplugin may save its internal private data here. The subplugin is responsible for alloc/free of this pointer.
+       * @param[in] in_info structure of input tensor info
+       * @param[out] out_info structure of output tensor info (return value)
+       * @return 0 if OK. non-zero if error.
+       */
+
+  int (*open) (const GstTensorFilter * filter, void **private_data);
+      /**< Optional. tensor_filter.c will call this before any of other callbacks and will call once before calling close
+       *
+       * @param[in] filter "this" pointer. Use this to read property values
+       * @param[in/out] private_data A subplugin may save its internal private data here. The subplugin is responsible for alloc/free of this pointer. Normally, open() allocates memory for private_data.
+       * @return 0 if ok. < 0 if error.
+       */
+
+  void (*close) (const GstTensorFilter * filter, void **private_data);
+      /**< Optional. tensor_filter.c will not call other callbacks after calling close. Free-ing private_data is this function's responsibility. Set NULL after that.
+       *
+       * @param[in] filter "this" pointer. Use this to read property values
+       * @param[in/out] private_data A subplugin may save its internal private data here. The subplugin is responsible for alloc/free of this pointer. Normally, close() frees private_data and set NULL.
+       */
+
+  void (*destroyNotify) (void * data);
+      /**< Optional. tensor_filter.c will call it when 'allocate_in_invoke' flag of the framework is TRUE. Basically, it is called when the data element is destroyed. If it's set as NULL, g_free() will be used as a default. It will be helpful when the data pointer is included as an object of a nnfw. For instance, if the data pointer is removed when the object is gone, it occurs error. In this case, the objects should be maintained for a while first and destroyed when the data pointer is destroyed. Those kinds of logic could be defined at this method.
+       * 
+       * @param[in] data the data element.
+       */
+};
+
+/* extern functions for subplugin management */
+extern gboolean tensor_filter_probe (GstTensorFilterFramework *tfsp);
+extern void tensor_filter_exit (const gchar *name);
+
 G_END_DECLS
 
 #endif /* __GST_TENSOR_FILTER_H__ */
diff --git a/gst/nnstreamer/tensor_filter/tensor_filter_custom.c b/gst/nnstreamer/tensor_filter/tensor_filter_custom.c
index 5a1be82..5b58bdd 100644
--- a/gst/nnstreamer/tensor_filter/tensor_filter_custom.c
+++ b/gst/nnstreamer/tensor_filter/tensor_filter_custom.c
@@ -52,27 +52,28 @@ typedef struct _internal_data internal_data;
  * @return 0 if successfully loaded. 1 if skipped (already loaded). -1 if error
  */
 static int
-custom_loadlib (const GstTensorFilterProperties * prop, void **private_data)
+custom_loadlib (const GstTensorFilter * filter, void **private_data)
 {
   internal_data *ptr;
   char *dlsym_error;
 
-  if (*private_data != NULL) {
+  if (filter->privateData != NULL) {
     /** @todo : Check the integrity of filter->data and filter->model_file, nnfw */
     return 1;
   }
 
-  if (!prop->model_file || prop->model_file[0] == '\0') {
+  if (!filter->prop.model_file || filter->prop.model_file[0] == '\0') {
     /* The .so file path is not given */
     return -1;
   }
 
   ptr = g_new0 (internal_data, 1);      /* Fill Zero! */
   *private_data = ptr;
+  g_assert (*private_data == filter->privateData);
   ptr->parent = GstTensorFilter_of_privateData (private_data);
 
   /* Load .so if this is the first time for this instance. */
-  ptr->handle = dlopen (prop->model_file, RTLD_NOW);
+  ptr->handle = dlopen (filter->prop.model_file, RTLD_NOW);
   if (!ptr->handle) {
     g_free (ptr);
     *private_data = NULL;
@@ -92,7 +93,7 @@ custom_loadlib (const GstTensorFilterProperties * prop, void **private_data)
   }
 
   g_assert (ptr->methods->initfunc);
-  ptr->customFW_private_data = ptr->methods->initfunc (prop);
+  ptr->customFW_private_data = ptr->methods->initfunc (&(filter->prop));
 
   /* After init func, (getInput XOR setInput) && (getOutput XOR setInput) must hold! */
   /** @todo Double check if this check is really required and safe */
@@ -106,9 +107,9 @@ custom_loadlib (const GstTensorFilterProperties * prop, void **private_data)
  * @brief The open callback for GstTensorFilterFramework. Called before anything else
  */
 static int
-custom_open (const GstTensorFilterProperties * prop, void **private_data)
+custom_open (const GstTensorFilter * filter, void **private_data)
 {
-  int retval = custom_loadlib (prop, private_data);
+  int retval = custom_loadlib (filter, private_data);
   internal_data *ptr;
 
   /* This must be called only once */
@@ -127,29 +128,29 @@ custom_open (const GstTensorFilterProperties * prop, void **private_data)
 
 /**
  * @brief The mandatory callback for GstTensorFilterFramework
- * @param prop The properties of parent object
+ * @param filter The parent object
  * @param[in] input The array of input tensors
  * @param[out] output The array of output tensors
  * @return 0 if OK. non-zero if error.
  */
 static int
-custom_invoke (const GstTensorFilterProperties * prop, void **private_data,
+custom_invoke (const GstTensorFilter * filter, void **private_data,
     const GstTensorMemory * input, GstTensorMemory * output)
 {
-  int retval = custom_loadlib (prop, private_data);
+  int retval = custom_loadlib (filter, private_data);
   internal_data *ptr;
 
   /* Actually, tensor_filter must have called getInput/OotputDim first. */
   g_assert (retval == 1);
-  g_assert (*private_data);
+  g_assert (filter->privateData && *private_data == filter->privateData);
   ptr = *private_data;
 
   if (ptr->methods->invoke) {
-    return ptr->methods->invoke (ptr->customFW_private_data, prop,
+    return ptr->methods->invoke (ptr->customFW_private_data, &(filter->prop),
         input, output);
   } else if (ptr->methods->allocate_invoke) {
     return ptr->methods->allocate_invoke (ptr->customFW_private_data,
-        prop, input, output);
+        &(filter->prop), input, output);
   } else {
     return -1;
   }
@@ -159,76 +160,79 @@ custom_invoke (const GstTensorFilterProperties * prop, void **private_data,
  * @brief The optional callback for GstTensorFilterFramework
  */
 static int
-custom_getInputDim (const GstTensorFilterProperties * prop, void **private_data,
+custom_getInputDim (const GstTensorFilter * filter, void **private_data,
     GstTensorsInfo * info)
 {
-  int retval = custom_loadlib (prop, private_data);
+  int retval = custom_loadlib (filter, private_data);
   internal_data *ptr;
 
   g_assert (retval == 1);       /* open must be called before */
 
-  g_assert (*private_data);
+  g_assert (filter->privateData && *private_data == filter->privateData);
   ptr = *private_data;
   if (ptr->methods->getInputDim == NULL) {
     return -1;
   }
 
-  return ptr->methods->getInputDim (ptr->customFW_private_data, prop, info);
+  return ptr->methods->getInputDim (ptr->customFW_private_data, &(filter->prop),
+      info);
 }
 
 /**
  * @brief The optional callback for GstTensorFilterFramework
  */
 static int
-custom_getOutputDim (const GstTensorFilterProperties * prop,
-    void **private_data, GstTensorsInfo * info)
+custom_getOutputDim (const GstTensorFilter * filter, void **private_data,
+    GstTensorsInfo * info)
 {
-  int retval = custom_loadlib (prop, private_data);
+  int retval = custom_loadlib (filter, private_data);
   internal_data *ptr;
 
   g_assert (retval == 1);       /* open must be called before */
 
-  g_assert (*private_data);
+  g_assert (filter->privateData && *private_data == filter->privateData);
   ptr = *private_data;
   if (ptr->methods->getOutputDim == NULL) {
     return -1;
   }
 
-  return ptr->methods->getOutputDim (ptr->customFW_private_data, prop, info);
+  return ptr->methods->getOutputDim (ptr->customFW_private_data,
+      &(filter->prop), info);
 }
 
 /**
  * @brief The set-input-dim callback for GstTensorFilterFramework
  */
 static int
-custom_setInputDim (const GstTensorFilterProperties * prop, void **private_data,
+custom_setInputDim (const GstTensorFilter * filter, void **private_data,
     const GstTensorsInfo * in_info, GstTensorsInfo * out_info)
 {
-  int retval = custom_loadlib (prop, private_data);
+  int retval = custom_loadlib (filter, private_data);
   internal_data *ptr;
 
   g_assert (retval == 1);       /* open must be called before */
 
-  g_assert (*private_data);
+  g_assert (filter->privateData && *private_data == filter->privateData);
   ptr = *private_data;
   if (ptr->methods->setInputDim == NULL)
     return -1;
 
   return ptr->methods->setInputDim (ptr->customFW_private_data,
-      prop, in_info, out_info);
+      &(filter->prop), in_info, out_info);
 }
 
 /**
  * @brief Free privateData and move on.
  */
 static void
-custom_close (const GstTensorFilterProperties * prop, void **private_data)
+custom_close (const GstTensorFilter * filter, void **private_data)
 {
   internal_data *ptr = *private_data;
 
-  ptr->methods->exitfunc (ptr->customFW_private_data, prop);
+  ptr->methods->exitfunc (ptr->customFW_private_data, &(filter->prop));
   g_free (ptr);
   *private_data = NULL;
+  g_assert (filter->privateData == NULL);
 }
 
 static GstTensorFilterFramework NNS_support_custom = {
diff --git a/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow.c b/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow.c
index 296a306..1c4ac3e 100644
--- a/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow.c
+++ b/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow.c
@@ -26,7 +26,7 @@
  *
  */
 
-#include <tensor_typedef.h>
+#include "tensor_filter.h"
 #include "tensor_filter_tensorflow_core.h"
 #include <glib.h>
 #include <string.h>
@@ -45,78 +45,76 @@ typedef struct _Tf_data tf_data;
  * @brief Free privateData and move on.
  */
 static void
-tf_close (const GstTensorFilterProperties * prop, void **private_data)
+tf_close (const GstTensorFilter * filter, void **private_data)
 {
   tf_data *tf;
   tf = *private_data;
   tf_core_delete (tf->tf_private_data);
   g_free (tf);
   *private_data = NULL;
+  g_assert (filter->privateData == NULL);
 }
 
 /**
  * @brief Load tensorflow modelfile
- * @param prop: property of tensor_filter instance
+ * @param filter : tensor_filter instance
  * @param private_data : tensorflow plugin's private data
  * @return 0 if successfully loaded. 1 if skipped (already loaded).
  *        -1 if the object construction is failed.
  *        -2 if the object initialization if failed
  */
 static int
-tf_loadModelFile (const GstTensorFilterProperties * prop, void **private_data)
+tf_loadModelFile (const GstTensorFilter * filter, void **private_data)
 {
   tf_data *tf;
-  if (*private_data != NULL) {
+  if (filter->privateData != NULL) {
+    /** @todo : Check the integrity of filter->data and filter->model_file, nnfw */
     tf = *private_data;
-    if (strcmp (prop->model_file, tf_core_getModelPath (tf->tf_private_data))) {
-      tf_close (prop, private_data);
+    if (strcmp (filter->prop.model_file,
+            tf_core_getModelPath (tf->tf_private_data))) {
+      tf_close (filter, private_data);
     } else {
       return 1;
     }
   }
   tf = g_new0 (tf_data, 1); /** initialize tf Fill Zero! */
   *private_data = tf;
-  tf->tf_private_data = tf_core_new (prop->model_file);
+  tf->tf_private_data = tf_core_new (filter->prop.model_file);
   if (tf->tf_private_data) {
-    if (tf_core_init (tf->tf_private_data, prop)) {
-      g_printerr ("failed to initailize the object: tensorflow");
+    if (tf_core_init (tf->tf_private_data, &filter->prop))
       return -2;
-    }
     return 0;
   } else {
-    g_printerr ("failed to create the object: tensorflow");
     return -1;
   }
 }
 
 /**
  * @brief The open callback for GstTensorFilterFramework. Called before anything else
- * @param prop: property of tensor_filter instance
+ * @param filter : tensor_filter instance
  * @param private_data : tensorflow plugin's private data
  */
 static int
-tf_open (const GstTensorFilterProperties * prop, void **private_data)
+tf_open (const GstTensorFilter * filter, void **private_data)
 {
-  int retval = tf_loadModelFile (prop, private_data);
+  int retval = tf_loadModelFile (filter, private_data);
   g_assert (retval == 0);       /** This must be called only once */
   return 0;
 }
 
 /**
  * @brief The mandatory callback for GstTensorFilterFramework
- * @param prop: property of tensor_filter instance
- * @param private_data : tensorflow plugin's private data
  * @param[in] input The array of input tensors
  * @param[out] output The array of output tensors
  */
 static int
-tf_run (const GstTensorFilterProperties * prop, void **private_data,
+tf_run (const GstTensorFilter * filter, void **private_data,
     const GstTensorMemory * input, GstTensorMemory * output)
 {
   int retval;
   tf_data *tf;
   tf = *private_data;
-  g_assert (*private_data);
+  g_assert (filter->privateData && *private_data == filter->privateData);
   retval = tf_core_run (tf->tf_private_data, input, output);
   g_assert (retval == 0);
   return retval;
@@ -124,34 +122,28 @@ tf_run (const GstTensorFilterProperties * prop, void **private_data,
 
 /**
  * @brief The optional callback for GstTensorFilterFramework
- * @param prop: property of tensor_filter instance
- * @param private_data : tensorflow plugin's private data
- * @param[out] info The dimesions and types of input tensors
  */
 static int
-tf_getInputDim (const GstTensorFilterProperties * prop, void **private_data,
+tf_getInputDim (const GstTensorFilter * filter, void **private_data,
     GstTensorsInfo * info)
 {
   tf_data *tf;
   tf = *private_data;
-  g_assert (*private_data);
+  g_assert (filter->privateData && *private_data == filter->privateData);
   int ret = tf_core_getInputDim (tf->tf_private_data, info);
   return ret;
 }
 
 /**
  * @brief The optional callback for GstTensorFilterFramework
- * @param prop: property of tensor_filter instance
- * @param private_data : tensorflow plugin's private data
- * @param[out] info The dimesions and types of output tensors
  */
 static int
-tf_getOutputDim (const GstTensorFilterProperties * prop, void **private_data,
+tf_getOutputDim (const GstTensorFilter * filter, void **private_data,
     GstTensorsInfo * info)
 {
   tf_data *tf;
   tf = *private_data;
-  g_assert (*private_data);
+  g_assert (filter->privateData && *private_data == filter->privateData);
   int ret = tf_core_getOutputDim (tf->tf_private_data, info);
   return ret;
 }
diff --git a/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow_core.cc b/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow_core.cc
index 8af38b0..36e76fc 100644
--- a/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow_core.cc
+++ b/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow_core.cc
@@ -33,7 +33,7 @@
 #define DBG FALSE
 #endif
 
-std::map <void*, Tensor> TFCore::outputTensorMap;
+std::map<void*, Tensor> TFCore::outputTensorMap;
 
 /**
  * @brief	TFCore creator
@@ -41,7 +41,7 @@ std::map <void*, Tensor> TFCore::outputTensorMap;
  * @note	the model of _model_path will be loaded simultaneously
  * @return	Nothing
  */
-TFCore::TFCore (const char * _model_path)
+TFCore::TFCore (const char *_model_path)
 {
   model_path = _model_path;
 
@@ -113,34 +113,34 @@ TFCore::loadModel ()
 #endif
   GraphDef graph_def;
   Status load_graph_status =
-      ReadBinaryProto (Env::Default (), model_path, &graph_def);
+      ReadBinaryProto(Env::Default(), model_path, &graph_def);
   if (!load_graph_status.ok()) {
     GST_ERROR ("Failed to load compute graph at '%s'", model_path);
     return -1;
   }
 
   /* get input tensor */
-  std::vector <const NodeDef*> placeholders;
-  for (const NodeDef& node : graph_def.node ()) {
-    if (node.op () == "Placeholder") {
-      placeholders.push_back (&node);
+  std::vector<const NodeDef*> placeholders;
+  for (const NodeDef& node : graph_def.node()) {
+    if (node.op() == "Placeholder") {
+      placeholders.push_back(&node);
     }
   }
 
-  if (placeholders.empty ()) {
+  if (placeholders.empty()) {
     GST_WARNING ("No inputs spotted.");
   } else {
-    GST_INFO ("Found possible inputs: %ld", placeholders.size ());
-    if (inputTensorValidation (placeholders)) {
+    GST_INFO ("Found possible inputs: %ld", placeholders.size());
+    if (inputTensorValidation(placeholders)) {
       GST_ERROR ("Input Tensor Information is not valid");
       return -2;
     }
   }
 
   /* get session */
-  Status new_session_status = NewSession (SessionOptions (), &session);
-  Status session_create_status = session->Create (graph_def);
-  if (!new_session_status.ok () || !session_create_status.ok ()) {
+  Status new_session_status = NewSession(SessionOptions(), &session);
+  Status session_create_status = session->Create(graph_def);
+  if (!new_session_status.ok() || !session_create_status.ok()) {
     GST_ERROR ("Create Tensorflow Session was Failed");
     return -3;
   }
@@ -235,67 +235,67 @@ TFCore::getTensorTypeToTF (tensor_type tType)
  *        -5 if the rank of input tensors exceeds our capacity NNS_TENSOR_RANK_LIMIT.
  */
 int
-TFCore::inputTensorValidation (const std::vector <const NodeDef*> &placeholders)
+TFCore::inputTensorValidation (const std::vector<const NodeDef*> &placeholders)
 {
-  int length = placeholders.size ();
+  int length = placeholders.size();
 
-  if (inputTensorMeta.num_tensors != length) {
+  if (inputTensorMeta.num_tensors != length){
     GST_ERROR ("Input Tensor is not valid: the number of input tensor is different\n");
     return -1;
   }
 
-  for (int i = 0; i < length; ++i) {
+  for (int i = 0; i < length; i++) {
     const NodeDef* node = placeholders[i];
     string shape_description = "None";
-    if (node->attr ().count ("shape")) {
-      TensorShapeProto shape_proto = node->attr ().at ("shape").shape ();
-      Status shape_status = PartialTensorShape::IsValidShape (shape_proto);
-      if (shape_status.ok ()) {
-        shape_description = PartialTensorShape (shape_proto).DebugString ();
+    if (node->attr().count("shape")) {
+      TensorShapeProto shape_proto = node->attr().at("shape").shape();
+      Status shape_status = PartialTensorShape::IsValidShape(shape_proto);
+      if (shape_status.ok()) {
+        shape_description = PartialTensorShape(shape_proto).DebugString();
       } else {
-        shape_description = shape_status.error_message ();
+        shape_description = shape_status.error_message();
       }
     }
     char chars[] = "[]";
-    for (unsigned int i = 0; i < strlen (chars); ++i)
+    for (unsigned int i = 0; i < strlen(chars); ++i)
     {
       shape_description.erase (
-        std::remove (
-          shape_description.begin (),
-          shape_description.end (),
+        std::remove(
+          shape_description.begin(),
+          shape_description.end(),
           chars[i]
         ),
-        shape_description.end ()
+        shape_description.end()
       );
     }
 
     DataType dtype = DT_INVALID;
-    if (node->attr ().count ("dtype")) {
-      dtype = node->attr ().at ("dtype").type ();
+    if (node->attr().count("dtype")) {
+      dtype = node->attr().at("dtype").type();
     }
 
-    if (strcmp (inputTensorMeta.info[i].name, node->name ().c_str ())) {
+    if (strcmp (inputTensorMeta.info[i].name, node->name().c_str())){
       GST_ERROR ("Input Tensor is not valid: the name of input tensor is different\n");
       return -2;
     }
-    if (inputTensorMeta.info[i].type != getTensorTypeFromTF (dtype)) {
+    if (inputTensorMeta.info[i].type != getTensorTypeFromTF(dtype)){
       GST_ERROR ("Input Tensor is not valid: the type of input tensor is different\n");
       return -3;
     }
 
     gchar **str_dims;
-    str_dims = g_strsplit (shape_description.c_str (), ",", -1);
+    str_dims = g_strsplit (shape_description.c_str(), ",", -1);
     inputTensorRank[i] = g_strv_length (str_dims);
     if (inputTensorRank[i] > NNS_TENSOR_RANK_LIMIT) {
       GST_ERROR ("The Rank of Input Tensor is not affordable. It's over our capacity.\n");
       g_strfreev (str_dims);
       return -5;
     }
-    for (int j = 0; j < inputTensorRank[i]; ++j) {
+    for (int j = 0; j < inputTensorRank[i]; j++) {
       if (!strcmp (str_dims[j], "?"))
         continue;
 
-      if (inputTensorMeta.info[i].dimension[inputTensorRank[i] - j - 1] != atoi (str_dims[j])) {
+      if (inputTensorMeta.info[i].dimension[inputTensorRank[i] - j - 1] != atoi (str_dims[j])){
         GST_ERROR ("Input Tensor is not valid: the dim of input tensor is different\n");
         g_strfreev (str_dims);
         return -4;
@@ -370,11 +370,11 @@ TFCore::getOutputTensorDim (GstTensorsInfo * info)
 
 #define copyInputWithType(type) do { \
     for (int idx = 0; idx < array_len; ++idx) \
-      inputTensor.flat<type> ()(idx) = ((type*) input[i].data)[idx]; \
+      inputTensor.flat<type>()(idx) = ((type*)input[i].data)[idx]; \
   } while (0)
 
 #define copyOutputWithType(type) do { \
-    output[i].data = outputs[i].flat<type> ().data (); \
+    output[i].data = outputs[i].flat<type>().data(); \
     outputTensorMap.insert (std::make_pair (output[i].data, outputs[i])); \
   } while (0)
 
@@ -388,18 +388,18 @@ TFCore::getOutputTensorDim (GstTensorsInfo * info)
 int
 TFCore::run (const GstTensorMemory * input, GstTensorMemory * output)
 {
-  std::vector <std::pair <string, Tensor>> input_feeds;
-  std::vector <string> output_tensor_names;
-  std::vector <Tensor> outputs;
+  std::vector<std::pair<string, Tensor>> input_feeds;
+  std::vector<string> output_tensor_names;
+  std::vector<Tensor> outputs;
   int array_len;
 
-  for (int i = 0; i < inputTensorMeta.num_tensors; ++i) {
-    TensorShape ts = TensorShape ({});
-    for (int j = inputTensorRank[i] - 1; j >= 0; j--) {
-      ts.AddDim (inputTensorMeta.info[i].dimension[j]);
+  for (int i = 0; i < inputTensorMeta.num_tensors; i++) {
+    TensorShape ts = TensorShape({});
+    for (int j = inputTensorRank[i] - 1; j >= 0; j--){
+      ts.AddDim(inputTensorMeta.info[i].dimension[j]);
     }
-    Tensor inputTensor (
-      getTensorTypeToTF (input[i].type),
+    Tensor inputTensor(
+      getTensorTypeToTF(input[i].type),
       ts
     );
 
@@ -441,25 +441,25 @@ TFCore::run (const GstTensorMemory * input, GstTensorMemory * output)
         break;
     }
 
-    input_feeds.push_back ({inputTensorMeta.info[i].name, inputTensor});
+    input_feeds.push_back({inputTensorMeta.info[i].name, inputTensor});
   }
 
-  for (int i = 0; i < outputTensorMeta.num_tensors; ++i) {
-    output_tensor_names.push_back (outputTensorMeta.info[i].name);
+  for (int i = 0; i < outputTensorMeta.num_tensors; i++) {
+    output_tensor_names.push_back(outputTensorMeta.info[i].name);
   }
 
   Status run_status =
-      session->Run (input_feeds, output_tensor_names, {}, &outputs);
+      session->Run(input_feeds, output_tensor_names, {}, &outputs);
 
-  if (run_status != Status::OK ()) {
+  if (run_status != Status::OK ()){
     GST_ERROR ("Failed to run model: %s\n", (run_status.ToString ()).c_str ());
     return -1;
   }
 
-  for (int i = 0; i < outputTensorMeta.num_tensors; ++i) {
+  for (int i = 0; i < outputTensorMeta.num_tensors; i++) {
     output[i].type = getTensorTypeFromTF (outputs[i].dtype());
     output[i].size = tensor_element_size[output[i].type];
-    for (int j = 0; j < NNS_TENSOR_RANK_LIMIT; ++j)
+    for (int j = 0; j < NNS_TENSOR_RANK_LIMIT; j++)
       output[i].size *= outputTensorMeta.info[i].dimension[j];
 
     array_len = output[i].size / tensor_element_size[output[i].type];
@@ -504,8 +504,8 @@ TFCore::run (const GstTensorMemory * input, GstTensorMemory * output)
   return 0;
 }
 
-void *
-tf_core_new (const char * _model_path)
+extern void *
+tf_core_new (const char *_model_path)
 {
   return new TFCore (_model_path);
 }
@@ -515,8 +515,8 @@ tf_core_new (const char * _model_path)
  * @param	tf	: the class object
  * @return	Nothing
  */
-void
-tf_core_delete (void * tf)
+extern void
+tf_core_delete (void *tf)
 {
   TFCore *c = (TFCore *) tf;
   delete c;
@@ -528,7 +528,7 @@ tf_core_delete (void * tf)
  * @return 0 if OK. non-zero if error.
  */
 int
-tf_core_init (void * tf, const GstTensorFilterProperties * prop)
+tf_core_init (void *tf, const GstTensorFilterProperties * prop)
 {
   TFCore *c = (TFCore *) tf;
   int ret = c->init (prop);
@@ -540,8 +540,8 @@ tf_core_init (void * tf, const GstTensorFilterProperties * prop)
  * @param	tf	: the class object
  * @return	model path
  */
-const char *
-tf_core_getModelPath (void * tf)
+extern const char *
+tf_core_getModelPath (void *tf)
 {
   TFCore *c = (TFCore *) tf;
   return c->getModelPath ();
@@ -554,7 +554,7 @@ tf_core_getModelPath (void * tf)
  * @return 0 if OK. non-zero if error.
  */
 int
-tf_core_getInputDim (void * tf, GstTensorsInfo * info)
+tf_core_getInputDim (void *tf, GstTensorsInfo * info)
 {
   TFCore *c = (TFCore *) tf;
   return c->getInputTensorDim (info);
@@ -567,7 +567,7 @@ tf_core_getInputDim (void * tf, GstTensorsInfo * info)
  * @return 0 if OK. non-zero if error.
  */
 int
-tf_core_getOutputDim (void * tf, GstTensorsInfo * info)
+tf_core_getOutputDim (void *tf, GstTensorsInfo * info)
 {
   TFCore *c = (TFCore *) tf;
   return c->getOutputTensorDim (info);
@@ -581,7 +581,7 @@ tf_core_getOutputDim (void * tf, GstTensorsInfo * info)
  * @return 0 if OK. non-zero if error.
  */
 int
-tf_core_run (void * tf, const GstTensorMemory * input, GstTensorMemory * output)
+tf_core_run (void *tf, const GstTensorMemory * input, GstTensorMemory * output)
 {
   TFCore *c = (TFCore *) tf;
   return c->run (input, output);
@@ -592,7 +592,6 @@ tf_core_run (void * tf, const GstTensorMemory * input, GstTensorMemory * output)
  * @param[in] data : the data element destroyed at the pipeline
  */
 void
-tf_core_destroyNotify (void * data)
-{
+tf_core_destroyNotify (void * data){
   TFCore::outputTensorMap.erase (data);
 }
diff --git a/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow_core.h b/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow_core.h
index 26bf7db..34435fc 100644
--- a/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow_core.h
+++ b/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow_core.h
@@ -26,8 +26,6 @@
 #ifndef TENSOR_FILTER_TENSORFLOW_H
 #define TENSOR_FILTER_TENSORFLOW_H
 
-#include <tensor_typedef.h>
-
 #ifdef __cplusplus
 #include <glib.h>
 #include <gst/gst.h>
@@ -50,6 +48,7 @@
 #include <tensorflow/core/lib/strings/str_util.h>
 #include <tensorflow/tools/graph_transforms/transform_utils.h>
 
+#include <tensor_typedef.h>
 
 using namespace tensorflow;
 
@@ -62,7 +61,7 @@ public:
   /**
    * member functions.
    */
-  TFCore (const char * _model_path);
+  TFCore (const char *_model_path);
    ~TFCore ();
 
   int init(const GstTensorFilterProperties * prop);
@@ -77,7 +76,7 @@ public:
   int getOutputTensorDim (GstTensorsInfo * info);
   int run (const GstTensorMemory * input, GstTensorMemory * output);
 
-  static std::map <void*, Tensor> outputTensorMap;
+  static std::map<void*, Tensor> outputTensorMap;
 
 private:
 
@@ -89,12 +88,12 @@ private:
   int inputTensorRank[NNS_TENSOR_SIZE_LIMIT];
   int outputTensorRank[NNS_TENSOR_SIZE_LIMIT];
 
-  Session *session;
+  Session * session;
 
   tensor_type getTensorTypeFromTF (DataType tfType);
   DataType getTensorTypeToTF (tensor_type tType);
   int setTensorProp (GstTensorsInfo * dest, const GstTensorsInfo * src);
-  int inputTensorValidation (const std::vector <const NodeDef*> &placeholders);
+  int inputTensorValidation (const std::vector<const NodeDef*> &placeholders);
 };
 
 /**
@@ -104,15 +103,15 @@ extern "C"
 {
 #endif
 
-  void *tf_core_new (const char *_model_path);
-  void tf_core_delete (void * tf);
-  int tf_core_init (void * tf, const GstTensorFilterProperties * prop);
-  const char *tf_core_getModelPath (void * tf);
-  int tf_core_getInputDim (void * tf, GstTensorsInfo * info);
-  int tf_core_getOutputDim (void * tf, GstTensorsInfo * info);
-  int tf_core_run (void * tf, const GstTensorMemory * input,
+  extern void *tf_core_new (const char *_model_path);
+  extern void tf_core_delete (void *tf);
+  extern int tf_core_init (void *tf, const GstTensorFilterProperties * prop);
+  extern const char *tf_core_getModelPath (void *tf);
+  extern int tf_core_getInputDim (void *tf, GstTensorsInfo * info);
+  extern int tf_core_getOutputDim (void *tf, GstTensorsInfo * info);
+  extern int tf_core_run (void *tf, const GstTensorMemory * input,
       GstTensorMemory * output);
-  void tf_core_destroyNotify (void * data);
+  extern void tf_core_destroyNotify (void * data);
 
 #ifdef __cplusplus
 }
diff --git a/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow_lite.c b/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow_lite.c
index 7b73a84..7e3fb9e 100644
--- a/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow_lite.c
+++ b/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow_lite.c
@@ -26,7 +26,7 @@
  *
  */
 
-#include <tensor_typedef.h>
+#include "tensor_filter.h"
 #include "tensor_filter_tensorflow_lite_core.h"
 #include <glib.h>
 #include <string.h>
@@ -45,80 +45,75 @@ typedef struct _Tflite_data tflite_data;
  * @brief Free privateData and move on.
  */
 static void
-tflite_close (const GstTensorFilterProperties * prop, void **private_data)
+tflite_close (const GstTensorFilter * filter, void **private_data)
 {
   tflite_data *tf;
   tf = *private_data;
   tflite_core_delete (tf->tflite_private_data);
   g_free (tf);
   *private_data = NULL;
+  g_assert (filter->privateData == NULL);
 }
 
 /**
  * @brief Load tensorflow lite modelfile
- * @param prop property of tensor_filter instance
+ * @param filter : tensor_filter instance
  * @param private_data : tensorflow lite plugin's private data
  * @return 0 if successfully loaded. 1 if skipped (already loaded).
  *        -1 if the object construction is failed.
  *        -2 if the object initialization if failed
  */
 static int
-tflite_loadModelFile (const GstTensorFilterProperties * prop,
-    void **private_data)
+tflite_loadModelFile (const GstTensorFilter * filter, void **private_data)
 {
   tflite_data *tf;
-  if (*private_data != NULL) {
+  if (filter->privateData != NULL) {
     /** @todo : Check the integrity of filter->data and filter->model_file, nnfw */
     tf = *private_data;
-    if (strcmp (prop->model_file,
+    if (strcmp (filter->prop.model_file,
             tflite_core_getModelPath (tf->tflite_private_data))) {
-      tflite_close (prop, private_data);
+      tflite_close (filter, private_data);
     } else {
       return 1;
     }
   }
   tf = g_new0 (tflite_data, 1); /** initialize tf Fill Zero! */
   *private_data = tf;
-  tf->tflite_private_data = tflite_core_new (prop->model_file);
+  tf->tflite_private_data = tflite_core_new (filter->prop.model_file);
   if (tf->tflite_private_data) {
-    if (tflite_core_init (tf->tflite_private_data)) {
-      g_printerr ("failed to initialize the object: Tensorflow-lite");
+    if (tflite_core_init (tf->tflite_private_data))
       return -2;
-    }
     return 0;
   } else {
-    g_printerr ("failed to create the object: Tensorflow-lite");
     return -1;
   }
 }
 
 /**
  * @brief The open callback for GstTensorFilterFramework. Called before anything else
- * @param prop property of tensor_filter instance
+ * @param filter : tensor_filter instance
  * @param private_data : tensorflow lite plugin's private data
  */
 static int
-tflite_open (const GstTensorFilterProperties * prop, void **private_data)
+tflite_open (const GstTensorFilter * filter, void **private_data)
 {
-  return tflite_loadModelFile (prop, private_data);
+  return tflite_loadModelFile (filter, private_data);
 }
 
 /**
  * @brief The mandatory callback for GstTensorFilterFramework
- * @param prop property of tensor_filter instance
- * @param private_data : tensorflow lite plugin's private data
  * @param[in] input The array of input tensors
  * @param[out] output The array of output tensors
  * @return 0 if OK. non-zero if error.
  */
 static int
-tflite_invoke (const GstTensorFilterProperties * prop, void **private_data,
+tflite_invoke (const GstTensorFilter * filter, void **private_data,
     const GstTensorMemory * input, GstTensorMemory * output)
 {
   int retval;
   tflite_data *tf;
   tf = *private_data;
-  g_assert (*private_data);
+  g_assert (filter->privateData && *private_data == filter->privateData);
   retval = tflite_core_invoke (tf->tflite_private_data, input, output);
   g_assert (retval == 0);
   return retval;
@@ -126,34 +121,28 @@ tflite_invoke (const GstTensorFilterProperties * prop, void **private_data,
 
 /**
  * @brief The optional callback for GstTensorFilterFramework
- * @param prop property of tensor_filter instance
- * @param private_data : tensorflow lite plugin's private data
- * @param[out] info The dimesions and types of input tensors
  */
 static int
-tflite_getInputDim (const GstTensorFilterProperties * prop, void **private_data,
+tflite_getInputDim (const GstTensorFilter * filter, void **private_data,
     GstTensorsInfo * info)
 {
   tflite_data *tf;
   tf = *private_data;
-  g_assert (*private_data);
+  g_assert (filter->privateData && *private_data == filter->privateData);
   int ret = tflite_core_getInputDim (tf->tflite_private_data, info);
   return ret;
 }
 
 /**
  * @brief The optional callback for GstTensorFilterFramework
- * @param prop property of tensor_filter instance
- * @param private_data : tensorflow lite plugin's private data
- * @param[out] info The dimesions and types of output tensors
  */
 static int
-tflite_getOutputDim (const GstTensorFilterProperties * prop,
-    void **private_data, GstTensorsInfo * info)
+tflite_getOutputDim (const GstTensorFilter * filter, void **private_data,
+    GstTensorsInfo * info)
 {
   tflite_data *tf;
   tf = *private_data;
-  g_assert (*private_data);
+  g_assert (filter->privateData && *private_data == filter->privateData);
   int ret = tflite_core_getOutputDim (tf->tflite_private_data, info);
   return ret;
 }
diff --git a/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow_lite_core.cc b/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow_lite_core.cc
index 69a5f75..5253178 100644
--- a/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow_lite_core.cc
+++ b/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow_lite_core.cc
@@ -39,7 +39,7 @@
  * @note	the model of _model_path will be loaded simultaneously
  * @return	Nothing
  */
-TFLiteCore::TFLiteCore (const char * _model_path)
+TFLiteCore::TFLiteCore (const char *_model_path)
 {
   model_path = _model_path;
 
@@ -104,7 +104,7 @@ TFLiteCore::loadModel ()
 
   if (!interpreter) {
     model =
-        std::unique_ptr <tflite::FlatBufferModel>
+        std::unique_ptr < tflite::FlatBufferModel >
         (tflite::FlatBufferModel::BuildFromFile (model_path));
     if (!model) {
       GST_ERROR ("Failed to mmap model\n");
@@ -187,7 +187,6 @@ TFLiteCore::setInputTensorProp ()
 
   for (int i = 0; i < inputTensorMeta.num_tensors; ++i) {
     if (getTensorDim (input_idx_list[i], inputTensorMeta.info[i].dimension)) {
-      GST_ERROR ("failed to get the dimension of input tensors");
       return -1;
     }
     inputTensorMeta.info[i].type =
@@ -216,7 +215,6 @@ TFLiteCore::setOutputTensorProp ()
 
   for (int i = 0; i < outputTensorMeta.num_tensors; ++i) {
     if (getTensorDim (output_idx_list[i], outputTensorMeta.info[i].dimension)) {
-      GST_ERROR ("failed to get the dimension of output tensors");
       return -1;
     }
     outputTensorMeta.info[i].type =
@@ -320,7 +318,7 @@ TFLiteCore::invoke (const GstTensorMemory * input, GstTensorMemory * output)
   gint64 start_time = g_get_real_time ();
 #endif
 
-  std::vector <int> tensors_idx;
+  std::vector<int> tensors_idx;
   int tensor_idx;
   TfLiteTensor *tensor_ptr;
 
@@ -368,7 +366,7 @@ TFLiteCore::invoke (const GstTensorMemory * input, GstTensorMemory * output)
  * @return	TFLiteCore class
  */
 void *
-tflite_core_new (const char * _model_path)
+tflite_core_new (const char *_model_path)
 {
   return new TFLiteCore (_model_path);
 }
@@ -379,7 +377,7 @@ tflite_core_new (const char * _model_path)
  * @return	Nothing
  */
 void
-tflite_core_delete (void * tflite)
+tflite_core_delete (void *tflite)
 {
   TFLiteCore *c = (TFLiteCore *) tflite;
   delete c;
@@ -391,7 +389,7 @@ tflite_core_delete (void * tflite)
  * @return 0 if OK. non-zero if error.
  */
 int
-tflite_core_init (void * tflite)
+tflite_core_init (void *tflite)
 {
   TFLiteCore *c = (TFLiteCore *) tflite;
   int ret = c->init ();
@@ -404,7 +402,7 @@ tflite_core_init (void * tflite)
  * @return the model path.
  */
 const char *
-tflite_core_getModelPath (void * tflite)
+tflite_core_getModelPath (void *tflite)
 {
   TFLiteCore *c = (TFLiteCore *) tflite;
   return c->getModelPath ();
@@ -417,7 +415,7 @@ tflite_core_getModelPath (void * tflite)
  * @return 0 if OK. non-zero if error.
  */
 int
-tflite_core_getInputDim (void * tflite, GstTensorsInfo * info)
+tflite_core_getInputDim (void *tflite, GstTensorsInfo * info)
 {
   TFLiteCore *c = (TFLiteCore *) tflite;
   int ret = c->getInputTensorDim (info);
@@ -431,7 +429,7 @@ tflite_core_getInputDim (void * tflite, GstTensorsInfo * info)
  * @return 0 if OK. non-zero if error.
  */
 int
-tflite_core_getOutputDim (void * tflite, GstTensorsInfo * info)
+tflite_core_getOutputDim (void *tflite, GstTensorsInfo * info)
 {
   TFLiteCore *c = (TFLiteCore *) tflite;
   int ret = c->getOutputTensorDim (info);
@@ -446,7 +444,7 @@ tflite_core_getOutputDim (void * tflite, GstTensorsInfo * info)
  * @return 0 if OK. non-zero if error.
  */
 int
-tflite_core_invoke (void * tflite, const GstTensorMemory * input,
+tflite_core_invoke (void *tflite, const GstTensorMemory * input,
     GstTensorMemory * output)
 {
   TFLiteCore *c = (TFLiteCore *) tflite;
diff --git a/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow_lite_core.h b/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow_lite_core.h
index b102f5b..9d7386c 100644
--- a/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow_lite_core.h
+++ b/gst/nnstreamer/tensor_filter/tensor_filter_tensorflow_lite_core.h
@@ -41,12 +41,12 @@
 class TFLiteCore
 {
 public:
-  TFLiteCore (const char * _model_path);
+  TFLiteCore (const char *_model_path);
   ~TFLiteCore ();
 
-  int init ();
+  int init();
   int loadModel ();
-  const char* getModelPath ();
+  const char* getModelPath();
   int setInputTensorProp ();
   int setOutputTensorProp ();
   int getInputTensorDim (GstTensorsInfo * info);
@@ -60,8 +60,8 @@ private:
   GstTensorsInfo inputTensorMeta;  /**< The tensor info of input tensors */
   GstTensorsInfo outputTensorMeta;  /**< The tensor info of output tensors */
 
-  std::unique_ptr <tflite::Interpreter> interpreter;
-  std::unique_ptr <tflite::FlatBufferModel> model;
+  std::unique_ptr < tflite::Interpreter > interpreter;
+  std::unique_ptr < tflite::FlatBufferModel > model;
 
   int getInputTensorSize ();
   int getOutputTensorSize ();
@@ -76,13 +76,13 @@ extern "C"
 {
 #endif
 
-  void *tflite_core_new (const char *_model_path);
-  void tflite_core_delete (void * tflite);
-  int tflite_core_init (void * tflite);
-  const char *tflite_core_getModelPath (void * tflite);
-  int tflite_core_getInputDim (void * tflite, GstTensorsInfo * info);
-  int tflite_core_getOutputDim (void * tflite, GstTensorsInfo * info);
-  int tflite_core_invoke (void * tflite, const GstTensorMemory * input,
+  extern void *tflite_core_new (const char *_model_path);
+  extern void tflite_core_delete (void *tflite);
+  extern int tflite_core_init (void *tflite);
+  extern const char *tflite_core_getModelPath (void *tflite);
+  extern int tflite_core_getInputDim (void *tflite, GstTensorsInfo * info);
+  extern int tflite_core_getOutputDim (void *tflite, GstTensorsInfo * info);
+  extern int tflite_core_invoke (void *tflite, const GstTensorMemory * input,
       GstTensorMemory * output);
 
 #ifdef __cplusplus
diff --git a/gst/nnstreamer/tensor_reposink/tensor_reposink.h b/gst/nnstreamer/tensor_reposink/tensor_reposink.h
index 86e5ee4..73d81dd 100644
--- a/gst/nnstreamer/tensor_reposink/tensor_reposink.h
+++ b/gst/nnstreamer/tensor_reposink/tensor_reposink.h
@@ -24,7 +24,7 @@
  * @bug		No known bugs except for NYI items
  */
 
-#ifndef __GST_TENSOR_REPOSINK_H_
+#ifndef __GST_TENSOR_REPOSINK_H__
 #define __GST_TENSOR_REPOSINK_H__
 
 #include <gst/gst.h>
diff --git a/gst/nnstreamer/tensor_reposrc/tensor_reposrc.h b/gst/nnstreamer/tensor_reposrc/tensor_reposrc.h
index 3c81de1..625edca 100644
--- a/gst/nnstreamer/tensor_reposrc/tensor_reposrc.h
+++ b/gst/nnstreamer/tensor_reposrc/tensor_reposrc.h
@@ -24,7 +24,7 @@
  * @bug		No known bugs except for NYI items
  */
 
-#ifndef __GST_TENSOR_REPOSRC_H_
+#ifndef __GST_TENSOR_REPOSRC_H__
 #define __GST_TENSOR_REPOSRC_H__
 
 #include <gst/gst.h>
diff --git a/gst/nnstreamer/tensor_transform/transform-orc.c b/gst/nnstreamer/tensor_transform/transform-orc.c
new file mode 100644
index 0000000..643aaea
--- /dev/null
+++ b/gst/nnstreamer/tensor_transform/transform-orc.c
@@ -0,0 +1,9285 @@
+
+/* autogenerated from transform-orc.orc */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include <glib.h>
+
+#ifndef _ORC_INTEGER_TYPEDEFS_
+#define _ORC_INTEGER_TYPEDEFS_
+#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+#include <stdint.h>
+typedef int8_t orc_int8;
+typedef int16_t orc_int16;
+typedef int32_t orc_int32;
+typedef int64_t orc_int64;
+typedef uint8_t orc_uint8;
+typedef uint16_t orc_uint16;
+typedef uint32_t orc_uint32;
+typedef uint64_t orc_uint64;
+#define ORC_UINT64_C(x) UINT64_C(x)
+#elif defined(_MSC_VER)
+typedef signed __int8 orc_int8;
+typedef signed __int16 orc_int16;
+typedef signed __int32 orc_int32;
+typedef signed __int64 orc_int64;
+typedef unsigned __int8 orc_uint8;
+typedef unsigned __int16 orc_uint16;
+typedef unsigned __int32 orc_uint32;
+typedef unsigned __int64 orc_uint64;
+#define ORC_UINT64_C(x) (x##Ui64)
+#define inline __inline
+#else
+#include <limits.h>
+typedef signed char orc_int8;
+typedef short orc_int16;
+typedef int orc_int32;
+typedef unsigned char orc_uint8;
+typedef unsigned short orc_uint16;
+typedef unsigned int orc_uint32;
+#if INT_MAX == LONG_MAX
+typedef long long orc_int64;
+typedef unsigned long long orc_uint64;
+#define ORC_UINT64_C(x) (x##ULL)
+#else
+typedef long orc_int64;
+typedef unsigned long orc_uint64;
+#define ORC_UINT64_C(x) (x##UL)
+#endif
+#endif
+typedef union { orc_int16 i; orc_int8 x2[2]; } orc_union16;
+typedef union { orc_int32 i; float f; orc_int16 x2[2]; orc_int8 x4[4]; } orc_union32;
+typedef union { orc_int64 i; double f; orc_int32 x2[2]; float x2f[2]; orc_int16 x4[4]; } orc_union64;
+#endif
+#ifndef ORC_RESTRICT
+#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+#define ORC_RESTRICT restrict
+#elif defined(__GNUC__) && __GNUC__ >= 4
+#define ORC_RESTRICT __restrict__
+#else
+#define ORC_RESTRICT
+#endif
+#endif
+
+#ifndef ORC_INTERNAL
+#if defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590)
+#define ORC_INTERNAL __attribute__((visibility("hidden")))
+#elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
+#define ORC_INTERNAL __hidden
+#elif defined (__GNUC__)
+#define ORC_INTERNAL __attribute__((visibility("hidden")))
+#else
+#define ORC_INTERNAL
+#endif
+#endif
+
+
+#ifndef DISABLE_ORC
+#include <orc/orc.h>
+#endif
+void nns_orc_add_c_s8 (orc_int8 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_mul_c_s8 (orc_int8 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_conv_s8_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s8_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s8_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s8_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s8_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s8_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s8_to_f32 (float * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s8_to_f64 (double * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n);
+void nns_orc_add_c_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_mul_c_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_conv_u8_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u8_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u8_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u8_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u8_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u8_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u8_to_f32 (float * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u8_to_f64 (double * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n);
+void nns_orc_add_c_s16 (orc_int16 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_mul_c_s16 (orc_int16 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_conv_s16_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s16_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s16_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s16_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s16_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s16_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s16_to_f32 (float * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s16_to_f64 (double * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n);
+void nns_orc_add_c_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_mul_c_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_conv_u16_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u16_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u16_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u16_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u16_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u16_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u16_to_f32 (float * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u16_to_f64 (double * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n);
+void nns_orc_add_c_s32 (orc_int32 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_mul_c_s32 (orc_int32 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_conv_s32_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s32_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s32_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s32_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s32_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s32_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s32_to_f32 (float * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s32_to_f64 (double * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n);
+void nns_orc_add_c_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_mul_c_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_conv_u32_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u32_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u32_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u32_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u32_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u32_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u32_to_f32 (float * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u32_to_f64 (double * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n);
+void nns_orc_add_c_f32 (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, float p1, int n);
+void nns_orc_mul_c_f32 (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, float p1, int n);
+void nns_orc_div_c_f32 (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, float p1, int n);
+void nns_orc_conv_f32_to_s8 (orc_int8 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f32_to_u8 (orc_uint8 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f32_to_s16 (orc_int16 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f32_to_u16 (orc_uint16 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f32_to_s32 (orc_int32 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f32_to_u32 (orc_uint32 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f32_to_f32 (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f32_to_f64 (double * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n);
+void nns_orc_add_c_f64 (double * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, double p1, int n);
+void nns_orc_mul_c_f64 (double * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, double p1, int n);
+void nns_orc_div_c_f64 (double * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, double p1, int n);
+void nns_orc_conv_f64_to_s8 (orc_int8 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f64_to_u8 (orc_uint8 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f64_to_s16 (orc_int16 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f64_to_u16 (orc_uint16 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f64_to_s32 (orc_int32 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f64_to_u32 (orc_uint32 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f64_to_f32 (float * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f64_to_f64 (double * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n);
+
+
+/* begin Orc C target preamble */
+#define ORC_CLAMP(x,a,b) ((x)<(a) ? (a) : ((x)>(b) ? (b) : (x)))
+#define ORC_ABS(a) ((a)<0 ? -(a) : (a))
+#define ORC_MIN(a,b) ((a)<(b) ? (a) : (b))
+#define ORC_MAX(a,b) ((a)>(b) ? (a) : (b))
+#define ORC_SB_MAX 127
+#define ORC_SB_MIN (-1-ORC_SB_MAX)
+#define ORC_UB_MAX 255
+#define ORC_UB_MIN 0
+#define ORC_SW_MAX 32767
+#define ORC_SW_MIN (-1-ORC_SW_MAX)
+#define ORC_UW_MAX 65535
+#define ORC_UW_MIN 0
+#define ORC_SL_MAX 2147483647
+#define ORC_SL_MIN (-1-ORC_SL_MAX)
+#define ORC_UL_MAX 4294967295U
+#define ORC_UL_MIN 0
+#define ORC_CLAMP_SB(x) ORC_CLAMP(x,ORC_SB_MIN,ORC_SB_MAX)
+#define ORC_CLAMP_UB(x) ORC_CLAMP(x,ORC_UB_MIN,ORC_UB_MAX)
+#define ORC_CLAMP_SW(x) ORC_CLAMP(x,ORC_SW_MIN,ORC_SW_MAX)
+#define ORC_CLAMP_UW(x) ORC_CLAMP(x,ORC_UW_MIN,ORC_UW_MAX)
+#define ORC_CLAMP_SL(x) ORC_CLAMP(x,ORC_SL_MIN,ORC_SL_MAX)
+#define ORC_CLAMP_UL(x) ORC_CLAMP(x,ORC_UL_MIN,ORC_UL_MAX)
+#define ORC_SWAP_W(x) ((((x)&0xffU)<<8) | (((x)&0xff00U)>>8))
+#define ORC_SWAP_L(x) ((((x)&0xffU)<<24) | (((x)&0xff00U)<<8) | (((x)&0xff0000U)>>8) | (((x)&0xff000000U)>>24))
+#define ORC_SWAP_Q(x) ((((x)&ORC_UINT64_C(0xff))<<56) | (((x)&ORC_UINT64_C(0xff00))<<40) | (((x)&ORC_UINT64_C(0xff0000))<<24) | (((x)&ORC_UINT64_C(0xff000000))<<8) | (((x)&ORC_UINT64_C(0xff00000000))>>8) | (((x)&ORC_UINT64_C(0xff0000000000))>>24) | (((x)&ORC_UINT64_C(0xff000000000000))>>40) | (((x)&ORC_UINT64_C(0xff00000000000000))>>56))
+#define ORC_PTR_OFFSET(ptr,offset) ((void *)(((unsigned char *)(ptr)) + (offset)))
+#define ORC_DENORMAL(x) ((x) & ((((x)&0x7f800000) == 0) ? 0xff800000 : 0xffffffff))
+#define ORC_ISNAN(x) ((((x)&0x7f800000) == 0x7f800000) && (((x)&0x007fffff) != 0))
+#define ORC_DENORMAL_DOUBLE(x) ((x) & ((((x)&ORC_UINT64_C(0x7ff0000000000000)) == 0) ? ORC_UINT64_C(0xfff0000000000000) : ORC_UINT64_C(0xffffffffffffffff)))
+#define ORC_ISNAN_DOUBLE(x) ((((x)&ORC_UINT64_C(0x7ff0000000000000)) == ORC_UINT64_C(0x7ff0000000000000)) && (((x)&ORC_UINT64_C(0x000fffffffffffff)) != 0))
+#ifndef ORC_RESTRICT
+#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+#define ORC_RESTRICT restrict
+#elif defined(__GNUC__) && __GNUC__ >= 4
+#define ORC_RESTRICT __restrict__
+#else
+#define ORC_RESTRICT
+#endif
+#endif
+/* end Orc C target preamble */
+
+
+
+/* nns_orc_add_c_s8 */
+#ifdef DISABLE_ORC
+void
+nns_orc_add_c_s8 (orc_int8 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int p1, int n){
+  int i;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var32;
+  orc_int8 var33;
+  orc_int8 var34;
+
+  ptr0 = (orc_int8 *)d1;
+  ptr4 = (orc_int8 *)s1;
+
+    /* 1: loadpb */
+    var33 = p1;
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var32 = ptr4[i];
+    /* 2: addssb */
+    var34 = ORC_CLAMP_SB(var32 + var33);
+    /* 3: storeb */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_add_c_s8 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var32;
+  orc_int8 var33;
+  orc_int8 var34;
+
+  ptr0 = (orc_int8 *)ex->arrays[0];
+  ptr4 = (orc_int8 *)ex->arrays[4];
+
+    /* 1: loadpb */
+    var33 = ex->params[24];
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var32 = ptr4[i];
+    /* 2: addssb */
+    var34 = ORC_CLAMP_SB(var32 + var33);
+    /* 3: storeb */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_add_c_s8 (orc_int8 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int p1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 16, 110, 110, 115, 95, 111, 114, 99, 95, 97, 100, 100, 95, 99, 
+        95, 115, 56, 11, 1, 1, 12, 1, 1, 16, 1, 34, 0, 4, 24, 2, 
+        0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_add_c_s8);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_add_c_s8");
+      orc_program_set_backup_function (p, _backup_nns_orc_add_c_s8);
+      orc_program_add_destination (p, 1, "d1");
+      orc_program_add_source (p, 1, "s1");
+      orc_program_add_parameter (p, 1, "p1");
+
+      orc_program_append_2 (p, "addssb", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+  ex->params[ORC_VAR_P1] = p1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_mul_c_s8 */
+#ifdef DISABLE_ORC
+void
+nns_orc_mul_c_s8 (orc_int8 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int p1, int n){
+  int i;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var33;
+  orc_int8 var34;
+  orc_int8 var35;
+  orc_union16 var36;
+
+  ptr0 = (orc_int8 *)d1;
+  ptr4 = (orc_int8 *)s1;
+
+    /* 1: loadpb */
+    var34 = p1;
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var33 = ptr4[i];
+    /* 2: mulsbw */
+    var36.i = var33 * var34;
+    /* 3: convssswb */
+    var35 = ORC_CLAMP_SB(var36.i);
+    /* 4: storeb */
+    ptr0[i] = var35;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_mul_c_s8 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var33;
+  orc_int8 var34;
+  orc_int8 var35;
+  orc_union16 var36;
+
+  ptr0 = (orc_int8 *)ex->arrays[0];
+  ptr4 = (orc_int8 *)ex->arrays[4];
+
+    /* 1: loadpb */
+    var34 = ex->params[24];
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var33 = ptr4[i];
+    /* 2: mulsbw */
+    var36.i = var33 * var34;
+    /* 3: convssswb */
+    var35 = ORC_CLAMP_SB(var36.i);
+    /* 4: storeb */
+    ptr0[i] = var35;
+  }
+
+}
+
+void
+nns_orc_mul_c_s8 (orc_int8 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int p1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 16, 110, 110, 115, 95, 111, 114, 99, 95, 109, 117, 108, 95, 99, 
+        95, 115, 56, 11, 1, 1, 12, 1, 1, 16, 1, 20, 2, 174, 32, 4, 
+        24, 159, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_mul_c_s8);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_mul_c_s8");
+      orc_program_set_backup_function (p, _backup_nns_orc_mul_c_s8);
+      orc_program_add_destination (p, 1, "d1");
+      orc_program_add_source (p, 1, "s1");
+      orc_program_add_parameter (p, 1, "p1");
+      orc_program_add_temporary (p, 2, "t1");
+
+      orc_program_append_2 (p, "mulsbw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+  ex->params[ORC_VAR_P1] = p1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s8_to_s8 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s8_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var32;
+  orc_int8 var33;
+
+  ptr0 = (orc_int8 *)d1;
+  ptr4 = (orc_int8 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var32 = ptr4[i];
+    /* 1: copyb */
+    var33 = var32;
+    /* 2: storeb */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s8_to_s8 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var32;
+  orc_int8 var33;
+
+  ptr0 = (orc_int8 *)ex->arrays[0];
+  ptr4 = (orc_int8 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var32 = ptr4[i];
+    /* 1: copyb */
+    var33 = var32;
+    /* 2: storeb */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_s8_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 21, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 56, 95, 116, 111, 95, 115, 56, 11, 1, 1, 12, 1, 1, 42, 0, 
+        4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s8_to_s8);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s8_to_s8");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s8_to_s8);
+      orc_program_add_destination (p, 1, "d1");
+      orc_program_add_source (p, 1, "s1");
+
+      orc_program_append_2 (p, "copyb", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s8_to_u8 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s8_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var32;
+  orc_int8 var33;
+
+  ptr0 = (orc_int8 *)d1;
+  ptr4 = (orc_int8 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var32 = ptr4[i];
+    /* 1: copyb */
+    var33 = var32;
+    /* 2: storeb */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s8_to_u8 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var32;
+  orc_int8 var33;
+
+  ptr0 = (orc_int8 *)ex->arrays[0];
+  ptr4 = (orc_int8 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var32 = ptr4[i];
+    /* 1: copyb */
+    var33 = var32;
+    /* 2: storeb */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_s8_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 21, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 56, 95, 116, 111, 95, 117, 56, 11, 1, 1, 12, 1, 1, 42, 0, 
+        4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s8_to_u8);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s8_to_u8");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s8_to_u8);
+      orc_program_add_destination (p, 1, "d1");
+      orc_program_add_source (p, 1, "s1");
+
+      orc_program_append_2 (p, "copyb", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s8_to_s16 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s8_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)d1;
+  ptr4 = (orc_int8 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var32 = ptr4[i];
+    /* 1: convsbw */
+    var33.i = var32;
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s8_to_s16 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)ex->arrays[0];
+  ptr4 = (orc_int8 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var32 = ptr4[i];
+    /* 1: convsbw */
+    var33.i = var32;
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_s8_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 56, 95, 116, 111, 95, 115, 49, 54, 11, 2, 2, 12, 1, 1, 149, 
+        0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s8_to_s16);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s8_to_s16");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s8_to_s16);
+      orc_program_add_destination (p, 2, "d1");
+      orc_program_add_source (p, 1, "s1");
+
+      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s8_to_u16 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s8_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)d1;
+  ptr4 = (orc_int8 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var32 = ptr4[i];
+    /* 1: convsbw */
+    var33.i = var32;
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s8_to_u16 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)ex->arrays[0];
+  ptr4 = (orc_int8 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var32 = ptr4[i];
+    /* 1: convsbw */
+    var33.i = var32;
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_s8_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 56, 95, 116, 111, 95, 117, 49, 54, 11, 2, 2, 12, 1, 1, 149, 
+        0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s8_to_u16);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s8_to_u16");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s8_to_u16);
+      orc_program_add_destination (p, 2, "d1");
+      orc_program_add_source (p, 1, "s1");
+
+      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s8_to_s32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s8_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var33;
+  orc_union32 var34;
+  orc_union16 var35;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_int8 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var33 = ptr4[i];
+    /* 1: convsbw */
+    var35.i = var33;
+    /* 2: convswl */
+    var34.i = var35.i;
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s8_to_s32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var33;
+  orc_union32 var34;
+  orc_union16 var35;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_int8 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var33 = ptr4[i];
+    /* 1: convsbw */
+    var35.i = var33;
+    /* 2: convswl */
+    var34.i = var35.i;
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_conv_s8_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 56, 95, 116, 111, 95, 115, 51, 50, 11, 4, 4, 12, 1, 1, 20, 
+        2, 149, 32, 4, 153, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s8_to_s32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s8_to_s32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s8_to_s32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 1, "s1");
+      orc_program_add_temporary (p, 2, "t1");
+
+      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convswl", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s8_to_u32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s8_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var33;
+  orc_union32 var34;
+  orc_union16 var35;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_int8 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var33 = ptr4[i];
+    /* 1: convsbw */
+    var35.i = var33;
+    /* 2: convswl */
+    var34.i = var35.i;
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s8_to_u32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var33;
+  orc_union32 var34;
+  orc_union16 var35;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_int8 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var33 = ptr4[i];
+    /* 1: convsbw */
+    var35.i = var33;
+    /* 2: convswl */
+    var34.i = var35.i;
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_conv_s8_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 56, 95, 116, 111, 95, 117, 51, 50, 11, 4, 4, 12, 1, 1, 20, 
+        2, 149, 32, 4, 153, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s8_to_u32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s8_to_u32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s8_to_u32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 1, "s1");
+      orc_program_add_temporary (p, 2, "t1");
+
+      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convswl", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s8_to_f32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s8_to_f32 (float * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var34;
+  orc_union32 var35;
+  orc_union16 var36;
+  orc_union32 var37;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_int8 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var34 = ptr4[i];
+    /* 1: convsbw */
+    var36.i = var34;
+    /* 2: convswl */
+    var37.i = var36.i;
+    /* 3: convlf */
+    var35.f = var37.i;
+    /* 4: storel */
+    ptr0[i] = var35;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s8_to_f32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var34;
+  orc_union32 var35;
+  orc_union16 var36;
+  orc_union32 var37;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_int8 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var34 = ptr4[i];
+    /* 1: convsbw */
+    var36.i = var34;
+    /* 2: convswl */
+    var37.i = var36.i;
+    /* 3: convlf */
+    var35.f = var37.i;
+    /* 4: storel */
+    ptr0[i] = var35;
+  }
+
+}
+
+void
+nns_orc_conv_s8_to_f32 (float * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 56, 95, 116, 111, 95, 102, 51, 50, 11, 4, 4, 12, 1, 1, 20, 
+        2, 20, 4, 149, 32, 4, 153, 33, 32, 211, 0, 33, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s8_to_f32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s8_to_f32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s8_to_f32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 1, "s1");
+      orc_program_add_temporary (p, 2, "t1");
+      orc_program_add_temporary (p, 4, "t2");
+
+      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convswl", 0, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convlf", 0, ORC_VAR_D1, ORC_VAR_T2, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s8_to_f64 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s8_to_f64 (double * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var34;
+  orc_union64 var35;
+  orc_union16 var36;
+  orc_union32 var37;
+
+  ptr0 = (orc_union64 *)d1;
+  ptr4 = (orc_int8 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var34 = ptr4[i];
+    /* 1: convsbw */
+    var36.i = var34;
+    /* 2: convswl */
+    var37.i = var36.i;
+    /* 3: convld */
+    var35.f = var37.i;
+    /* 4: storeq */
+    ptr0[i] = var35;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s8_to_f64 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var34;
+  orc_union64 var35;
+  orc_union16 var36;
+  orc_union32 var37;
+
+  ptr0 = (orc_union64 *)ex->arrays[0];
+  ptr4 = (orc_int8 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var34 = ptr4[i];
+    /* 1: convsbw */
+    var36.i = var34;
+    /* 2: convswl */
+    var37.i = var36.i;
+    /* 3: convld */
+    var35.f = var37.i;
+    /* 4: storeq */
+    ptr0[i] = var35;
+  }
+
+}
+
+void
+nns_orc_conv_s8_to_f64 (double * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 56, 95, 116, 111, 95, 102, 54, 52, 11, 8, 8, 12, 1, 1, 20, 
+        2, 20, 4, 149, 32, 4, 153, 33, 32, 223, 0, 33, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s8_to_f64);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s8_to_f64");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s8_to_f64);
+      orc_program_add_destination (p, 8, "d1");
+      orc_program_add_source (p, 1, "s1");
+      orc_program_add_temporary (p, 2, "t1");
+      orc_program_add_temporary (p, 4, "t2");
+
+      orc_program_append_2 (p, "convsbw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convswl", 0, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convld", 0, ORC_VAR_D1, ORC_VAR_T2, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_add_c_u8 */
+#ifdef DISABLE_ORC
+void
+nns_orc_add_c_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int p1, int n){
+  int i;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var32;
+  orc_int8 var33;
+  orc_int8 var34;
+
+  ptr0 = (orc_int8 *)d1;
+  ptr4 = (orc_int8 *)s1;
+
+    /* 1: loadpb */
+    var33 = p1;
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var32 = ptr4[i];
+    /* 2: addusb */
+    var34 = ORC_CLAMP_UB((orc_uint8)var32 + (orc_uint8)var33);
+    /* 3: storeb */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_add_c_u8 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var32;
+  orc_int8 var33;
+  orc_int8 var34;
+
+  ptr0 = (orc_int8 *)ex->arrays[0];
+  ptr4 = (orc_int8 *)ex->arrays[4];
+
+    /* 1: loadpb */
+    var33 = ex->params[24];
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var32 = ptr4[i];
+    /* 2: addusb */
+    var34 = ORC_CLAMP_UB((orc_uint8)var32 + (orc_uint8)var33);
+    /* 3: storeb */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_add_c_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int p1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 16, 110, 110, 115, 95, 111, 114, 99, 95, 97, 100, 100, 95, 99, 
+        95, 117, 56, 11, 1, 1, 12, 1, 1, 16, 1, 35, 0, 4, 24, 2, 
+        0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_add_c_u8);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_add_c_u8");
+      orc_program_set_backup_function (p, _backup_nns_orc_add_c_u8);
+      orc_program_add_destination (p, 1, "d1");
+      orc_program_add_source (p, 1, "s1");
+      orc_program_add_parameter (p, 1, "p1");
+
+      orc_program_append_2 (p, "addusb", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+  ex->params[ORC_VAR_P1] = p1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_mul_c_u8 */
+#ifdef DISABLE_ORC
+void
+nns_orc_mul_c_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int p1, int n){
+  int i;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var33;
+  orc_int8 var34;
+  orc_int8 var35;
+  orc_union16 var36;
+
+  ptr0 = (orc_int8 *)d1;
+  ptr4 = (orc_int8 *)s1;
+
+    /* 1: loadpb */
+    var34 = p1;
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var33 = ptr4[i];
+    /* 2: mulubw */
+    var36.i = ((orc_uint16)((orc_uint8)var33)) * ((orc_uint16)((orc_uint8)var34));
+    /* 3: convuuswb */
+    var35 = ORC_MIN((orc_uint16)var36.i,ORC_UB_MAX);
+    /* 4: storeb */
+    ptr0[i] = var35;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_mul_c_u8 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var33;
+  orc_int8 var34;
+  orc_int8 var35;
+  orc_union16 var36;
+
+  ptr0 = (orc_int8 *)ex->arrays[0];
+  ptr4 = (orc_int8 *)ex->arrays[4];
+
+    /* 1: loadpb */
+    var34 = ex->params[24];
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var33 = ptr4[i];
+    /* 2: mulubw */
+    var36.i = ((orc_uint16)((orc_uint8)var33)) * ((orc_uint16)((orc_uint8)var34));
+    /* 3: convuuswb */
+    var35 = ORC_MIN((orc_uint16)var36.i,ORC_UB_MAX);
+    /* 4: storeb */
+    ptr0[i] = var35;
+  }
+
+}
+
+void
+nns_orc_mul_c_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int p1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 16, 110, 110, 115, 95, 111, 114, 99, 95, 109, 117, 108, 95, 99, 
+        95, 117, 56, 11, 1, 1, 12, 1, 1, 16, 1, 20, 2, 175, 32, 4, 
+        24, 162, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_mul_c_u8);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_mul_c_u8");
+      orc_program_set_backup_function (p, _backup_nns_orc_mul_c_u8);
+      orc_program_add_destination (p, 1, "d1");
+      orc_program_add_source (p, 1, "s1");
+      orc_program_add_parameter (p, 1, "p1");
+      orc_program_add_temporary (p, 2, "t1");
+
+      orc_program_append_2 (p, "mulubw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convuuswb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+  ex->params[ORC_VAR_P1] = p1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u8_to_s8 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u8_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var32;
+  orc_int8 var33;
+
+  ptr0 = (orc_int8 *)d1;
+  ptr4 = (orc_int8 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var32 = ptr4[i];
+    /* 1: copyb */
+    var33 = var32;
+    /* 2: storeb */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u8_to_s8 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var32;
+  orc_int8 var33;
+
+  ptr0 = (orc_int8 *)ex->arrays[0];
+  ptr4 = (orc_int8 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var32 = ptr4[i];
+    /* 1: copyb */
+    var33 = var32;
+    /* 2: storeb */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_u8_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 21, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 56, 95, 116, 111, 95, 115, 56, 11, 1, 1, 12, 1, 1, 42, 0, 
+        4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u8_to_s8);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u8_to_s8");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u8_to_s8);
+      orc_program_add_destination (p, 1, "d1");
+      orc_program_add_source (p, 1, "s1");
+
+      orc_program_append_2 (p, "copyb", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u8_to_u8 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u8_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var32;
+  orc_int8 var33;
+
+  ptr0 = (orc_int8 *)d1;
+  ptr4 = (orc_int8 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var32 = ptr4[i];
+    /* 1: copyb */
+    var33 = var32;
+    /* 2: storeb */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u8_to_u8 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var32;
+  orc_int8 var33;
+
+  ptr0 = (orc_int8 *)ex->arrays[0];
+  ptr4 = (orc_int8 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var32 = ptr4[i];
+    /* 1: copyb */
+    var33 = var32;
+    /* 2: storeb */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_u8_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 21, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 56, 95, 116, 111, 95, 117, 56, 11, 1, 1, 12, 1, 1, 42, 0, 
+        4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u8_to_u8);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u8_to_u8");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u8_to_u8);
+      orc_program_add_destination (p, 1, "d1");
+      orc_program_add_source (p, 1, "s1");
+
+      orc_program_append_2 (p, "copyb", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u8_to_s16 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u8_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)d1;
+  ptr4 = (orc_int8 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var32 = ptr4[i];
+    /* 1: convubw */
+    var33.i = (orc_uint8)var32;
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u8_to_s16 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)ex->arrays[0];
+  ptr4 = (orc_int8 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var32 = ptr4[i];
+    /* 1: convubw */
+    var33.i = (orc_uint8)var32;
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_u8_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 56, 95, 116, 111, 95, 115, 49, 54, 11, 2, 2, 12, 1, 1, 150, 
+        0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u8_to_s16);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u8_to_s16");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u8_to_s16);
+      orc_program_add_destination (p, 2, "d1");
+      orc_program_add_source (p, 1, "s1");
+
+      orc_program_append_2 (p, "convubw", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u8_to_u16 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u8_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)d1;
+  ptr4 = (orc_int8 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var32 = ptr4[i];
+    /* 1: convubw */
+    var33.i = (orc_uint8)var32;
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u8_to_u16 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)ex->arrays[0];
+  ptr4 = (orc_int8 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var32 = ptr4[i];
+    /* 1: convubw */
+    var33.i = (orc_uint8)var32;
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_u8_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 56, 95, 116, 111, 95, 117, 49, 54, 11, 2, 2, 12, 1, 1, 150, 
+        0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u8_to_u16);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u8_to_u16");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u8_to_u16);
+      orc_program_add_destination (p, 2, "d1");
+      orc_program_add_source (p, 1, "s1");
+
+      orc_program_append_2 (p, "convubw", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u8_to_s32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u8_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var33;
+  orc_union32 var34;
+  orc_union16 var35;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_int8 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var33 = ptr4[i];
+    /* 1: convubw */
+    var35.i = (orc_uint8)var33;
+    /* 2: convuwl */
+    var34.i = (orc_uint16)var35.i;
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u8_to_s32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var33;
+  orc_union32 var34;
+  orc_union16 var35;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_int8 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var33 = ptr4[i];
+    /* 1: convubw */
+    var35.i = (orc_uint8)var33;
+    /* 2: convuwl */
+    var34.i = (orc_uint16)var35.i;
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_conv_u8_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 56, 95, 116, 111, 95, 115, 51, 50, 11, 4, 4, 12, 1, 1, 20, 
+        2, 150, 32, 4, 154, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u8_to_s32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u8_to_s32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u8_to_s32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 1, "s1");
+      orc_program_add_temporary (p, 2, "t1");
+
+      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convuwl", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u8_to_u32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u8_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var33;
+  orc_union32 var34;
+  orc_union16 var35;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_int8 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var33 = ptr4[i];
+    /* 1: convubw */
+    var35.i = (orc_uint8)var33;
+    /* 2: convuwl */
+    var34.i = (orc_uint16)var35.i;
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u8_to_u32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var33;
+  orc_union32 var34;
+  orc_union16 var35;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_int8 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var33 = ptr4[i];
+    /* 1: convubw */
+    var35.i = (orc_uint8)var33;
+    /* 2: convuwl */
+    var34.i = (orc_uint16)var35.i;
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_conv_u8_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 56, 95, 116, 111, 95, 117, 51, 50, 11, 4, 4, 12, 1, 1, 20, 
+        2, 150, 32, 4, 154, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u8_to_u32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u8_to_u32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u8_to_u32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 1, "s1");
+      orc_program_add_temporary (p, 2, "t1");
+
+      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convuwl", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u8_to_f32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u8_to_f32 (float * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var34;
+  orc_union32 var35;
+  orc_union16 var36;
+  orc_union32 var37;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_int8 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var34 = ptr4[i];
+    /* 1: convubw */
+    var36.i = (orc_uint8)var34;
+    /* 2: convuwl */
+    var37.i = (orc_uint16)var36.i;
+    /* 3: convlf */
+    var35.f = var37.i;
+    /* 4: storel */
+    ptr0[i] = var35;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u8_to_f32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var34;
+  orc_union32 var35;
+  orc_union16 var36;
+  orc_union32 var37;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_int8 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var34 = ptr4[i];
+    /* 1: convubw */
+    var36.i = (orc_uint8)var34;
+    /* 2: convuwl */
+    var37.i = (orc_uint16)var36.i;
+    /* 3: convlf */
+    var35.f = var37.i;
+    /* 4: storel */
+    ptr0[i] = var35;
+  }
+
+}
+
+void
+nns_orc_conv_u8_to_f32 (float * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 56, 95, 116, 111, 95, 102, 51, 50, 11, 4, 4, 12, 1, 1, 20, 
+        2, 20, 4, 150, 32, 4, 154, 33, 32, 211, 0, 33, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u8_to_f32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u8_to_f32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u8_to_f32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 1, "s1");
+      orc_program_add_temporary (p, 2, "t1");
+      orc_program_add_temporary (p, 4, "t2");
+
+      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convuwl", 0, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convlf", 0, ORC_VAR_D1, ORC_VAR_T2, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u8_to_f64 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u8_to_f64 (double * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var34;
+  orc_union64 var35;
+  orc_union16 var36;
+  orc_union32 var37;
+
+  ptr0 = (orc_union64 *)d1;
+  ptr4 = (orc_int8 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var34 = ptr4[i];
+    /* 1: convubw */
+    var36.i = (orc_uint8)var34;
+    /* 2: convuwl */
+    var37.i = (orc_uint16)var36.i;
+    /* 3: convld */
+    var35.f = var37.i;
+    /* 4: storeq */
+    ptr0[i] = var35;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u8_to_f64 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_int8 * ORC_RESTRICT ptr4;
+  orc_int8 var34;
+  orc_union64 var35;
+  orc_union16 var36;
+  orc_union32 var37;
+
+  ptr0 = (orc_union64 *)ex->arrays[0];
+  ptr4 = (orc_int8 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadb */
+    var34 = ptr4[i];
+    /* 1: convubw */
+    var36.i = (orc_uint8)var34;
+    /* 2: convuwl */
+    var37.i = (orc_uint16)var36.i;
+    /* 3: convld */
+    var35.f = var37.i;
+    /* 4: storeq */
+    ptr0[i] = var35;
+  }
+
+}
+
+void
+nns_orc_conv_u8_to_f64 (double * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 56, 95, 116, 111, 95, 102, 54, 52, 11, 8, 8, 12, 1, 1, 20, 
+        2, 20, 4, 150, 32, 4, 154, 33, 32, 223, 0, 33, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u8_to_f64);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u8_to_f64");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u8_to_f64);
+      orc_program_add_destination (p, 8, "d1");
+      orc_program_add_source (p, 1, "s1");
+      orc_program_add_temporary (p, 2, "t1");
+      orc_program_add_temporary (p, 4, "t2");
+
+      orc_program_append_2 (p, "convubw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convuwl", 0, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convld", 0, ORC_VAR_D1, ORC_VAR_T2, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_add_c_s16 */
+#ifdef DISABLE_ORC
+void
+nns_orc_add_c_s16 (orc_int16 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int p1, int n){
+  int i;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_union16 var33;
+  orc_union16 var34;
+
+  ptr0 = (orc_union16 *)d1;
+  ptr4 = (orc_union16 *)s1;
+
+    /* 1: loadpw */
+    var33.i = p1;
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 2: addssw */
+    var34.i = ORC_CLAMP_SW(var32.i + var33.i);
+    /* 3: storew */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_add_c_s16 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_union16 var33;
+  orc_union16 var34;
+
+  ptr0 = (orc_union16 *)ex->arrays[0];
+  ptr4 = (orc_union16 *)ex->arrays[4];
+
+    /* 1: loadpw */
+    var33.i = ex->params[24];
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 2: addssw */
+    var34.i = ORC_CLAMP_SW(var32.i + var33.i);
+    /* 3: storew */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_add_c_s16 (orc_int16 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int p1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 17, 110, 110, 115, 95, 111, 114, 99, 95, 97, 100, 100, 95, 99, 
+        95, 115, 49, 54, 11, 2, 2, 12, 2, 2, 16, 2, 71, 0, 4, 24, 
+        2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_add_c_s16);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_add_c_s16");
+      orc_program_set_backup_function (p, _backup_nns_orc_add_c_s16);
+      orc_program_add_destination (p, 2, "d1");
+      orc_program_add_source (p, 2, "s1");
+      orc_program_add_parameter (p, 2, "p1");
+
+      orc_program_append_2 (p, "addssw", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+  ex->params[ORC_VAR_P1] = p1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_mul_c_s16 */
+#ifdef DISABLE_ORC
+void
+nns_orc_mul_c_s16 (orc_int16 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int p1, int n){
+  int i;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var33;
+  orc_union16 var34;
+  orc_union16 var35;
+  orc_union32 var36;
+
+  ptr0 = (orc_union16 *)d1;
+  ptr4 = (orc_union16 *)s1;
+
+    /* 1: loadpw */
+    var34.i = p1;
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var33 = ptr4[i];
+    /* 2: mulswl */
+    var36.i = var33.i * var34.i;
+    /* 3: convssslw */
+    var35.i = ORC_CLAMP_SW(var36.i);
+    /* 4: storew */
+    ptr0[i] = var35;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_mul_c_s16 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var33;
+  orc_union16 var34;
+  orc_union16 var35;
+  orc_union32 var36;
+
+  ptr0 = (orc_union16 *)ex->arrays[0];
+  ptr4 = (orc_union16 *)ex->arrays[4];
+
+    /* 1: loadpw */
+    var34.i = ex->params[24];
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var33 = ptr4[i];
+    /* 2: mulswl */
+    var36.i = var33.i * var34.i;
+    /* 3: convssslw */
+    var35.i = ORC_CLAMP_SW(var36.i);
+    /* 4: storew */
+    ptr0[i] = var35;
+  }
+
+}
+
+void
+nns_orc_mul_c_s16 (orc_int16 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int p1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 17, 110, 110, 115, 95, 111, 114, 99, 95, 109, 117, 108, 95, 99, 
+        95, 115, 49, 54, 11, 2, 2, 12, 2, 2, 16, 2, 20, 4, 176, 32, 
+        4, 24, 165, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_mul_c_s16);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_mul_c_s16");
+      orc_program_set_backup_function (p, _backup_nns_orc_mul_c_s16);
+      orc_program_add_destination (p, 2, "d1");
+      orc_program_add_source (p, 2, "s1");
+      orc_program_add_parameter (p, 2, "p1");
+      orc_program_add_temporary (p, 4, "t1");
+
+      orc_program_append_2 (p, "mulswl", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convssslw", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+  ex->params[ORC_VAR_P1] = p1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s16_to_s8 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s16_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_int8 var33;
+
+  ptr0 = (orc_int8 *)d1;
+  ptr4 = (orc_union16 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: convssswb */
+    var33 = ORC_CLAMP_SB(var32.i);
+    /* 2: storeb */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s16_to_s8 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_int8 var33;
+
+  ptr0 = (orc_int8 *)ex->arrays[0];
+  ptr4 = (orc_union16 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: convssswb */
+    var33 = ORC_CLAMP_SB(var32.i);
+    /* 2: storeb */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_s16_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 49, 54, 95, 116, 111, 95, 115, 56, 11, 1, 1, 12, 2, 2, 159, 
+        0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s16_to_s8);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s16_to_s8");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s16_to_s8);
+      orc_program_add_destination (p, 1, "d1");
+      orc_program_add_source (p, 2, "s1");
+
+      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s16_to_u8 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s16_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_int8 var33;
+
+  ptr0 = (orc_int8 *)d1;
+  ptr4 = (orc_union16 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: convwb */
+    var33 = var32.i;
+    /* 2: storeb */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s16_to_u8 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_int8 var33;
+
+  ptr0 = (orc_int8 *)ex->arrays[0];
+  ptr4 = (orc_union16 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: convwb */
+    var33 = var32.i;
+    /* 2: storeb */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_s16_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 49, 54, 95, 116, 111, 95, 117, 56, 11, 1, 1, 12, 2, 2, 157, 
+        0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s16_to_u8);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s16_to_u8");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s16_to_u8);
+      orc_program_add_destination (p, 1, "d1");
+      orc_program_add_source (p, 2, "s1");
+
+      orc_program_append_2 (p, "convwb", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s16_to_s16 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s16_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)d1;
+  ptr4 = (orc_union16 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: copyw */
+    var33.i = var32.i;
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s16_to_s16 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)ex->arrays[0];
+  ptr4 = (orc_union16 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: copyw */
+    var33.i = var32.i;
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_s16_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 49, 54, 95, 116, 111, 95, 115, 49, 54, 11, 2, 2, 12, 2, 2, 
+        79, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s16_to_s16);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s16_to_s16");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s16_to_s16);
+      orc_program_add_destination (p, 2, "d1");
+      orc_program_add_source (p, 2, "s1");
+
+      orc_program_append_2 (p, "copyw", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s16_to_u16 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s16_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)d1;
+  ptr4 = (orc_union16 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: copyw */
+    var33.i = var32.i;
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s16_to_u16 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)ex->arrays[0];
+  ptr4 = (orc_union16 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: copyw */
+    var33.i = var32.i;
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_s16_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 49, 54, 95, 116, 111, 95, 117, 49, 54, 11, 2, 2, 12, 2, 2, 
+        79, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s16_to_u16);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s16_to_u16");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s16_to_u16);
+      orc_program_add_destination (p, 2, "d1");
+      orc_program_add_source (p, 2, "s1");
+
+      orc_program_append_2 (p, "copyw", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s16_to_s32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s16_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union16 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: convswl */
+    var33.i = var32.i;
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s16_to_s32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union16 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: convswl */
+    var33.i = var32.i;
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_s16_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 49, 54, 95, 116, 111, 95, 115, 51, 50, 11, 4, 4, 12, 2, 2, 
+        153, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s16_to_s32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s16_to_s32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s16_to_s32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 2, "s1");
+
+      orc_program_append_2 (p, "convswl", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s16_to_u32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s16_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var33;
+  orc_union32 var34;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union16 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var33 = ptr4[i];
+    /* 1: convswl */
+    var34.i = var33.i;
+    /* 2: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s16_to_u32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var33;
+  orc_union32 var34;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union16 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var33 = ptr4[i];
+    /* 1: convswl */
+    var34.i = var33.i;
+    /* 2: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_conv_s16_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 49, 54, 95, 116, 111, 95, 117, 51, 50, 11, 4, 4, 12, 2, 2, 
+        20, 4, 153, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s16_to_u32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s16_to_u32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s16_to_u32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 2, "s1");
+      orc_program_add_temporary (p, 4, "t1");
+
+      orc_program_append_2 (p, "convswl", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s16_to_f32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s16_to_f32 (float * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var33;
+  orc_union32 var34;
+  orc_union32 var35;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union16 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var33 = ptr4[i];
+    /* 1: convswl */
+    var35.i = var33.i;
+    /* 2: convlf */
+    var34.f = var35.i;
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s16_to_f32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var33;
+  orc_union32 var34;
+  orc_union32 var35;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union16 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var33 = ptr4[i];
+    /* 1: convswl */
+    var35.i = var33.i;
+    /* 2: convlf */
+    var34.f = var35.i;
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_conv_s16_to_f32 (float * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 49, 54, 95, 116, 111, 95, 102, 51, 50, 11, 4, 4, 12, 2, 2, 
+        20, 4, 153, 32, 4, 211, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s16_to_f32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s16_to_f32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s16_to_f32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 2, "s1");
+      orc_program_add_temporary (p, 4, "t1");
+
+      orc_program_append_2 (p, "convswl", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convlf", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s16_to_f64 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s16_to_f64 (double * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var33;
+  orc_union64 var34;
+  orc_union32 var35;
+
+  ptr0 = (orc_union64 *)d1;
+  ptr4 = (orc_union16 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var33 = ptr4[i];
+    /* 1: convswl */
+    var35.i = var33.i;
+    /* 2: convld */
+    var34.f = var35.i;
+    /* 3: storeq */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s16_to_f64 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var33;
+  orc_union64 var34;
+  orc_union32 var35;
+
+  ptr0 = (orc_union64 *)ex->arrays[0];
+  ptr4 = (orc_union16 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var33 = ptr4[i];
+    /* 1: convswl */
+    var35.i = var33.i;
+    /* 2: convld */
+    var34.f = var35.i;
+    /* 3: storeq */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_conv_s16_to_f64 (double * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 49, 54, 95, 116, 111, 95, 102, 54, 52, 11, 8, 8, 12, 2, 2, 
+        20, 4, 153, 32, 4, 223, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s16_to_f64);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s16_to_f64");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s16_to_f64);
+      orc_program_add_destination (p, 8, "d1");
+      orc_program_add_source (p, 2, "s1");
+      orc_program_add_temporary (p, 4, "t1");
+
+      orc_program_append_2 (p, "convswl", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convld", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_add_c_u16 */
+#ifdef DISABLE_ORC
+void
+nns_orc_add_c_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int p1, int n){
+  int i;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_union16 var33;
+  orc_union16 var34;
+
+  ptr0 = (orc_union16 *)d1;
+  ptr4 = (orc_union16 *)s1;
+
+    /* 1: loadpw */
+    var33.i = p1;
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 2: addusw */
+    var34.i = ORC_CLAMP_UW((orc_uint16)var32.i + (orc_uint16)var33.i);
+    /* 3: storew */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_add_c_u16 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_union16 var33;
+  orc_union16 var34;
+
+  ptr0 = (orc_union16 *)ex->arrays[0];
+  ptr4 = (orc_union16 *)ex->arrays[4];
+
+    /* 1: loadpw */
+    var33.i = ex->params[24];
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 2: addusw */
+    var34.i = ORC_CLAMP_UW((orc_uint16)var32.i + (orc_uint16)var33.i);
+    /* 3: storew */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_add_c_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int p1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 17, 110, 110, 115, 95, 111, 114, 99, 95, 97, 100, 100, 95, 99, 
+        95, 117, 49, 54, 11, 2, 2, 12, 2, 2, 16, 2, 72, 0, 4, 24, 
+        2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_add_c_u16);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_add_c_u16");
+      orc_program_set_backup_function (p, _backup_nns_orc_add_c_u16);
+      orc_program_add_destination (p, 2, "d1");
+      orc_program_add_source (p, 2, "s1");
+      orc_program_add_parameter (p, 2, "p1");
+
+      orc_program_append_2 (p, "addusw", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+  ex->params[ORC_VAR_P1] = p1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_mul_c_u16 */
+#ifdef DISABLE_ORC
+void
+nns_orc_mul_c_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int p1, int n){
+  int i;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var33;
+  orc_union16 var34;
+  orc_union16 var35;
+  orc_union32 var36;
+
+  ptr0 = (orc_union16 *)d1;
+  ptr4 = (orc_union16 *)s1;
+
+    /* 1: loadpw */
+    var34.i = p1;
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var33 = ptr4[i];
+    /* 2: muluwl */
+    var36.i = ((orc_uint32)((orc_uint16)var33.i)) * ((orc_uint32)((orc_uint16)var34.i));
+    /* 3: convuuslw */
+    var35.i = ORC_CLAMP_UW((orc_uint32)var36.i);
+    /* 4: storew */
+    ptr0[i] = var35;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_mul_c_u16 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var33;
+  orc_union16 var34;
+  orc_union16 var35;
+  orc_union32 var36;
+
+  ptr0 = (orc_union16 *)ex->arrays[0];
+  ptr4 = (orc_union16 *)ex->arrays[4];
+
+    /* 1: loadpw */
+    var34.i = ex->params[24];
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var33 = ptr4[i];
+    /* 2: muluwl */
+    var36.i = ((orc_uint32)((orc_uint16)var33.i)) * ((orc_uint32)((orc_uint16)var34.i));
+    /* 3: convuuslw */
+    var35.i = ORC_CLAMP_UW((orc_uint32)var36.i);
+    /* 4: storew */
+    ptr0[i] = var35;
+  }
+
+}
+
+void
+nns_orc_mul_c_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int p1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 17, 110, 110, 115, 95, 111, 114, 99, 95, 109, 117, 108, 95, 99, 
+        95, 117, 49, 54, 11, 2, 2, 12, 2, 2, 16, 2, 20, 4, 177, 32, 
+        4, 24, 168, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_mul_c_u16);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_mul_c_u16");
+      orc_program_set_backup_function (p, _backup_nns_orc_mul_c_u16);
+      orc_program_add_destination (p, 2, "d1");
+      orc_program_add_source (p, 2, "s1");
+      orc_program_add_parameter (p, 2, "p1");
+      orc_program_add_temporary (p, 4, "t1");
+
+      orc_program_append_2 (p, "muluwl", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convuuslw", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+  ex->params[ORC_VAR_P1] = p1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u16_to_s8 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u16_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_int8 var33;
+
+  ptr0 = (orc_int8 *)d1;
+  ptr4 = (orc_union16 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: convssswb */
+    var33 = ORC_CLAMP_SB(var32.i);
+    /* 2: storeb */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u16_to_s8 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_int8 var33;
+
+  ptr0 = (orc_int8 *)ex->arrays[0];
+  ptr4 = (orc_union16 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: convssswb */
+    var33 = ORC_CLAMP_SB(var32.i);
+    /* 2: storeb */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_u16_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 49, 54, 95, 116, 111, 95, 115, 56, 11, 1, 1, 12, 2, 2, 159, 
+        0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u16_to_s8);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u16_to_s8");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u16_to_s8);
+      orc_program_add_destination (p, 1, "d1");
+      orc_program_add_source (p, 2, "s1");
+
+      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u16_to_u8 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u16_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_int8 var33;
+
+  ptr0 = (orc_int8 *)d1;
+  ptr4 = (orc_union16 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: convwb */
+    var33 = var32.i;
+    /* 2: storeb */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u16_to_u8 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_int8 var33;
+
+  ptr0 = (orc_int8 *)ex->arrays[0];
+  ptr4 = (orc_union16 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: convwb */
+    var33 = var32.i;
+    /* 2: storeb */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_u16_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 49, 54, 95, 116, 111, 95, 117, 56, 11, 1, 1, 12, 2, 2, 157, 
+        0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u16_to_u8);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u16_to_u8");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u16_to_u8);
+      orc_program_add_destination (p, 1, "d1");
+      orc_program_add_source (p, 2, "s1");
+
+      orc_program_append_2 (p, "convwb", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u16_to_s16 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u16_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)d1;
+  ptr4 = (orc_union16 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: copyw */
+    var33.i = var32.i;
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u16_to_s16 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)ex->arrays[0];
+  ptr4 = (orc_union16 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: copyw */
+    var33.i = var32.i;
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_u16_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 49, 54, 95, 116, 111, 95, 115, 49, 54, 11, 2, 2, 12, 2, 2, 
+        79, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u16_to_s16);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u16_to_s16");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u16_to_s16);
+      orc_program_add_destination (p, 2, "d1");
+      orc_program_add_source (p, 2, "s1");
+
+      orc_program_append_2 (p, "copyw", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u16_to_u16 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u16_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)d1;
+  ptr4 = (orc_union16 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: copyw */
+    var33.i = var32.i;
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u16_to_u16 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)ex->arrays[0];
+  ptr4 = (orc_union16 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: copyw */
+    var33.i = var32.i;
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_u16_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 49, 54, 95, 116, 111, 95, 117, 49, 54, 11, 2, 2, 12, 2, 2, 
+        79, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u16_to_u16);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u16_to_u16");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u16_to_u16);
+      orc_program_add_destination (p, 2, "d1");
+      orc_program_add_source (p, 2, "s1");
+
+      orc_program_append_2 (p, "copyw", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u16_to_s32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u16_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union16 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: convuwl */
+    var33.i = (orc_uint16)var32.i;
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u16_to_s32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union16 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: convuwl */
+    var33.i = (orc_uint16)var32.i;
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_u16_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 49, 54, 95, 116, 111, 95, 115, 51, 50, 11, 4, 4, 12, 2, 2, 
+        154, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u16_to_s32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u16_to_s32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u16_to_s32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 2, "s1");
+
+      orc_program_append_2 (p, "convuwl", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u16_to_u32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u16_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union16 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: convuwl */
+    var33.i = (orc_uint16)var32.i;
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u16_to_u32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union16 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var32 = ptr4[i];
+    /* 1: convuwl */
+    var33.i = (orc_uint16)var32.i;
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_u16_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 49, 54, 95, 116, 111, 95, 117, 51, 50, 11, 4, 4, 12, 2, 2, 
+        154, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u16_to_u32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u16_to_u32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u16_to_u32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 2, "s1");
+
+      orc_program_append_2 (p, "convuwl", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u16_to_f32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u16_to_f32 (float * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var33;
+  orc_union32 var34;
+  orc_union32 var35;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union16 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var33 = ptr4[i];
+    /* 1: convuwl */
+    var35.i = (orc_uint16)var33.i;
+    /* 2: convlf */
+    var34.f = var35.i;
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u16_to_f32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var33;
+  orc_union32 var34;
+  orc_union32 var35;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union16 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var33 = ptr4[i];
+    /* 1: convuwl */
+    var35.i = (orc_uint16)var33.i;
+    /* 2: convlf */
+    var34.f = var35.i;
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_conv_u16_to_f32 (float * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 49, 54, 95, 116, 111, 95, 102, 51, 50, 11, 4, 4, 12, 2, 2, 
+        20, 4, 154, 32, 4, 211, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u16_to_f32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u16_to_f32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u16_to_f32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 2, "s1");
+      orc_program_add_temporary (p, 4, "t1");
+
+      orc_program_append_2 (p, "convuwl", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convlf", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u16_to_f64 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u16_to_f64 (double * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var33;
+  orc_union64 var34;
+  orc_union32 var35;
+
+  ptr0 = (orc_union64 *)d1;
+  ptr4 = (orc_union16 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var33 = ptr4[i];
+    /* 1: convuwl */
+    var35.i = (orc_uint16)var33.i;
+    /* 2: convld */
+    var34.f = var35.i;
+    /* 3: storeq */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u16_to_f64 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_union16 * ORC_RESTRICT ptr4;
+  orc_union16 var33;
+  orc_union64 var34;
+  orc_union32 var35;
+
+  ptr0 = (orc_union64 *)ex->arrays[0];
+  ptr4 = (orc_union16 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadw */
+    var33 = ptr4[i];
+    /* 1: convuwl */
+    var35.i = (orc_uint16)var33.i;
+    /* 2: convld */
+    var34.f = var35.i;
+    /* 3: storeq */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_conv_u16_to_f64 (double * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 49, 54, 95, 116, 111, 95, 102, 54, 52, 11, 8, 8, 12, 2, 2, 
+        20, 4, 154, 32, 4, 223, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u16_to_f64);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u16_to_f64");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u16_to_f64);
+      orc_program_add_destination (p, 8, "d1");
+      orc_program_add_source (p, 2, "s1");
+      orc_program_add_temporary (p, 4, "t1");
+
+      orc_program_append_2 (p, "convuwl", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convld", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_add_c_s32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_add_c_s32 (orc_int32 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int p1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+  orc_union32 var34;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+    /* 1: loadpl */
+    var33.i = p1;
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 2: addssl */
+    var34.i = ORC_CLAMP_SL((orc_int64)var32.i + (orc_int64)var33.i);
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_add_c_s32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+  orc_union32 var34;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+    /* 1: loadpl */
+    var33.i = ex->params[24];
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 2: addssl */
+    var34.i = ORC_CLAMP_SL((orc_int64)var32.i + (orc_int64)var33.i);
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_add_c_s32 (orc_int32 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int p1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 17, 110, 110, 115, 95, 111, 114, 99, 95, 97, 100, 100, 95, 99, 
+        95, 115, 51, 50, 11, 4, 4, 12, 4, 4, 16, 4, 104, 0, 4, 24, 
+        2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_add_c_s32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_add_c_s32");
+      orc_program_set_backup_function (p, _backup_nns_orc_add_c_s32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 4, "s1");
+      orc_program_add_parameter (p, 4, "p1");
+
+      orc_program_append_2 (p, "addssl", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+  ex->params[ORC_VAR_P1] = p1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_mul_c_s32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_mul_c_s32 (orc_int32 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int p1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var33;
+  orc_union32 var34;
+  orc_union32 var35;
+  orc_union64 var36;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+    /* 1: loadpl */
+    var34.i = p1;
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var33 = ptr4[i];
+    /* 2: mulslq */
+    var36.i = ((orc_int64)var33.i) * ((orc_int64)var34.i);
+    /* 3: convsssql */
+    var35.i = ORC_CLAMP_SL(var36.i);
+    /* 4: storel */
+    ptr0[i] = var35;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_mul_c_s32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var33;
+  orc_union32 var34;
+  orc_union32 var35;
+  orc_union64 var36;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+    /* 1: loadpl */
+    var34.i = ex->params[24];
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var33 = ptr4[i];
+    /* 2: mulslq */
+    var36.i = ((orc_int64)var33.i) * ((orc_int64)var34.i);
+    /* 3: convsssql */
+    var35.i = ORC_CLAMP_SL(var36.i);
+    /* 4: storel */
+    ptr0[i] = var35;
+  }
+
+}
+
+void
+nns_orc_mul_c_s32 (orc_int32 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int p1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 17, 110, 110, 115, 95, 111, 114, 99, 95, 109, 117, 108, 95, 99, 
+        95, 115, 51, 50, 11, 4, 4, 12, 4, 4, 16, 4, 20, 8, 178, 32, 
+        4, 24, 170, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_mul_c_s32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_mul_c_s32");
+      orc_program_set_backup_function (p, _backup_nns_orc_mul_c_s32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 4, "s1");
+      orc_program_add_parameter (p, 4, "p1");
+      orc_program_add_temporary (p, 8, "t1");
+
+      orc_program_append_2 (p, "mulslq", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convsssql", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+  ex->params[ORC_VAR_P1] = p1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s32_to_s8 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s32_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var33;
+  orc_int8 var34;
+  orc_union16 var35;
+
+  ptr0 = (orc_int8 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var33 = ptr4[i];
+    /* 1: convssslw */
+    var35.i = ORC_CLAMP_SW(var33.i);
+    /* 2: convssswb */
+    var34 = ORC_CLAMP_SB(var35.i);
+    /* 3: storeb */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s32_to_s8 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var33;
+  orc_int8 var34;
+  orc_union16 var35;
+
+  ptr0 = (orc_int8 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var33 = ptr4[i];
+    /* 1: convssslw */
+    var35.i = ORC_CLAMP_SW(var33.i);
+    /* 2: convssswb */
+    var34 = ORC_CLAMP_SB(var35.i);
+    /* 3: storeb */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_conv_s32_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 51, 50, 95, 116, 111, 95, 115, 56, 11, 1, 1, 12, 4, 4, 20, 
+        2, 165, 32, 4, 159, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s32_to_s8);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s32_to_s8");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s32_to_s8);
+      orc_program_add_destination (p, 1, "d1");
+      orc_program_add_source (p, 4, "s1");
+      orc_program_add_temporary (p, 2, "t1");
+
+      orc_program_append_2 (p, "convssslw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s32_to_u8 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s32_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var33;
+  orc_int8 var34;
+  orc_union16 var35;
+
+  ptr0 = (orc_int8 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var33 = ptr4[i];
+    /* 1: convlw */
+    var35.i = var33.i;
+    /* 2: convwb */
+    var34 = var35.i;
+    /* 3: storeb */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s32_to_u8 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var33;
+  orc_int8 var34;
+  orc_union16 var35;
+
+  ptr0 = (orc_int8 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var33 = ptr4[i];
+    /* 1: convlw */
+    var35.i = var33.i;
+    /* 2: convwb */
+    var34 = var35.i;
+    /* 3: storeb */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_conv_s32_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 51, 50, 95, 116, 111, 95, 117, 56, 11, 1, 1, 12, 4, 4, 20, 
+        2, 163, 32, 4, 157, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s32_to_u8);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s32_to_u8");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s32_to_u8);
+      orc_program_add_destination (p, 1, "d1");
+      orc_program_add_source (p, 4, "s1");
+      orc_program_add_temporary (p, 2, "t1");
+
+      orc_program_append_2 (p, "convlw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convwb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s32_to_s16 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s32_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: convssslw */
+    var33.i = ORC_CLAMP_SW(var32.i);
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s32_to_s16 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: convssslw */
+    var33.i = ORC_CLAMP_SW(var32.i);
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_s32_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 51, 50, 95, 116, 111, 95, 115, 49, 54, 11, 2, 2, 12, 4, 4, 
+        165, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s32_to_s16);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s32_to_s16");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s32_to_s16);
+      orc_program_add_destination (p, 2, "d1");
+      orc_program_add_source (p, 4, "s1");
+
+      orc_program_append_2 (p, "convssslw", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s32_to_u16 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s32_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var33;
+  orc_union16 var34;
+
+  ptr0 = (orc_union16 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var33 = ptr4[i];
+    /* 1: convssslw */
+    var34.i = ORC_CLAMP_SW(var33.i);
+    /* 2: storew */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s32_to_u16 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var33;
+  orc_union16 var34;
+
+  ptr0 = (orc_union16 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var33 = ptr4[i];
+    /* 1: convssslw */
+    var34.i = ORC_CLAMP_SW(var33.i);
+    /* 2: storew */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_conv_s32_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 51, 50, 95, 116, 111, 95, 117, 49, 54, 11, 2, 2, 12, 4, 4, 
+        20, 2, 165, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s32_to_u16);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s32_to_u16");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s32_to_u16);
+      orc_program_add_destination (p, 2, "d1");
+      orc_program_add_source (p, 4, "s1");
+      orc_program_add_temporary (p, 2, "t1");
+
+      orc_program_append_2 (p, "convssslw", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s32_to_s32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s32_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: copyl */
+    var33.i = var32.i;
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s32_to_s32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: copyl */
+    var33.i = var32.i;
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_s32_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 51, 50, 95, 116, 111, 95, 115, 51, 50, 11, 4, 4, 12, 4, 4, 
+        112, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s32_to_s32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s32_to_s32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s32_to_s32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 4, "s1");
+
+      orc_program_append_2 (p, "copyl", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s32_to_u32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s32_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: copyl */
+    var33.i = var32.i;
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s32_to_u32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: copyl */
+    var33.i = var32.i;
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_s32_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 51, 50, 95, 116, 111, 95, 117, 51, 50, 11, 4, 4, 12, 4, 4, 
+        112, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s32_to_u32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s32_to_u32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s32_to_u32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 4, "s1");
+
+      orc_program_append_2 (p, "copyl", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s32_to_f32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s32_to_f32 (float * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: convlf */
+    var33.f = var32.i;
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s32_to_f32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: convlf */
+    var33.f = var32.i;
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_s32_to_f32 (float * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 51, 50, 95, 116, 111, 95, 102, 51, 50, 11, 4, 4, 12, 4, 4, 
+        211, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s32_to_f32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s32_to_f32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s32_to_f32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 4, "s1");
+
+      orc_program_append_2 (p, "convlf", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_s32_to_f64 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_s32_to_f64 (double * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union64 var33;
+
+  ptr0 = (orc_union64 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: convld */
+    var33.f = var32.i;
+    /* 2: storeq */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_s32_to_f64 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union64 var33;
+
+  ptr0 = (orc_union64 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: convld */
+    var33.f = var32.i;
+    /* 2: storeq */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_s32_to_f64 (double * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        115, 51, 50, 95, 116, 111, 95, 102, 54, 52, 11, 8, 8, 12, 4, 4, 
+        223, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s32_to_f64);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_s32_to_f64");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_s32_to_f64);
+      orc_program_add_destination (p, 8, "d1");
+      orc_program_add_source (p, 4, "s1");
+
+      orc_program_append_2 (p, "convld", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_add_c_u32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_add_c_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int p1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+  orc_union32 var34;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+    /* 1: loadpl */
+    var33.i = p1;
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 2: addusl */
+    var34.i = ORC_CLAMP_UL((orc_int64)(orc_uint32)var32.i + (orc_int64)(orc_uint32)var33.i);
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_add_c_u32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+  orc_union32 var34;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+    /* 1: loadpl */
+    var33.i = ex->params[24];
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 2: addusl */
+    var34.i = ORC_CLAMP_UL((orc_int64)(orc_uint32)var32.i + (orc_int64)(orc_uint32)var33.i);
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_add_c_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int p1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 17, 110, 110, 115, 95, 111, 114, 99, 95, 97, 100, 100, 95, 99, 
+        95, 117, 51, 50, 11, 4, 4, 12, 4, 4, 16, 4, 105, 0, 4, 24, 
+        2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_add_c_u32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_add_c_u32");
+      orc_program_set_backup_function (p, _backup_nns_orc_add_c_u32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 4, "s1");
+      orc_program_add_parameter (p, 4, "p1");
+
+      orc_program_append_2 (p, "addusl", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+  ex->params[ORC_VAR_P1] = p1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_mul_c_u32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_mul_c_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int p1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var33;
+  orc_union32 var34;
+  orc_union32 var35;
+  orc_union64 var36;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+    /* 1: loadpl */
+    var34.i = p1;
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var33 = ptr4[i];
+    /* 2: mululq */
+    var36.i = ((orc_uint64)((orc_uint32)var33.i)) * ((orc_uint64)((orc_uint32)var34.i));
+    /* 3: convuusql */
+    var35.i = ORC_CLAMP_UL((orc_uint64)var36.i);
+    /* 4: storel */
+    ptr0[i] = var35;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_mul_c_u32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var33;
+  orc_union32 var34;
+  orc_union32 var35;
+  orc_union64 var36;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+    /* 1: loadpl */
+    var34.i = ex->params[24];
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var33 = ptr4[i];
+    /* 2: mululq */
+    var36.i = ((orc_uint64)((orc_uint32)var33.i)) * ((orc_uint64)((orc_uint32)var34.i));
+    /* 3: convuusql */
+    var35.i = ORC_CLAMP_UL((orc_uint64)var36.i);
+    /* 4: storel */
+    ptr0[i] = var35;
+  }
+
+}
+
+void
+nns_orc_mul_c_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int p1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 17, 110, 110, 115, 95, 111, 114, 99, 95, 109, 117, 108, 95, 99, 
+        95, 117, 51, 50, 11, 4, 4, 12, 4, 4, 16, 4, 20, 8, 179, 32, 
+        4, 24, 173, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_mul_c_u32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_mul_c_u32");
+      orc_program_set_backup_function (p, _backup_nns_orc_mul_c_u32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 4, "s1");
+      orc_program_add_parameter (p, 4, "p1");
+      orc_program_add_temporary (p, 8, "t1");
+
+      orc_program_append_2 (p, "mululq", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convuusql", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+  ex->params[ORC_VAR_P1] = p1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u32_to_s8 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u32_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var33;
+  orc_int8 var34;
+  orc_union16 var35;
+
+  ptr0 = (orc_int8 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var33 = ptr4[i];
+    /* 1: convssslw */
+    var35.i = ORC_CLAMP_SW(var33.i);
+    /* 2: convssswb */
+    var34 = ORC_CLAMP_SB(var35.i);
+    /* 3: storeb */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u32_to_s8 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var33;
+  orc_int8 var34;
+  orc_union16 var35;
+
+  ptr0 = (orc_int8 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var33 = ptr4[i];
+    /* 1: convssslw */
+    var35.i = ORC_CLAMP_SW(var33.i);
+    /* 2: convssswb */
+    var34 = ORC_CLAMP_SB(var35.i);
+    /* 3: storeb */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_conv_u32_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 51, 50, 95, 116, 111, 95, 115, 56, 11, 1, 1, 12, 4, 4, 20, 
+        2, 165, 32, 4, 159, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u32_to_s8);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u32_to_s8");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u32_to_s8);
+      orc_program_add_destination (p, 1, "d1");
+      orc_program_add_source (p, 4, "s1");
+      orc_program_add_temporary (p, 2, "t1");
+
+      orc_program_append_2 (p, "convssslw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u32_to_u8 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u32_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var33;
+  orc_int8 var34;
+  orc_union16 var35;
+
+  ptr0 = (orc_int8 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var33 = ptr4[i];
+    /* 1: convlw */
+    var35.i = var33.i;
+    /* 2: convwb */
+    var34 = var35.i;
+    /* 3: storeb */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u32_to_u8 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var33;
+  orc_int8 var34;
+  orc_union16 var35;
+
+  ptr0 = (orc_int8 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var33 = ptr4[i];
+    /* 1: convlw */
+    var35.i = var33.i;
+    /* 2: convwb */
+    var34 = var35.i;
+    /* 3: storeb */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_conv_u32_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 51, 50, 95, 116, 111, 95, 117, 56, 11, 1, 1, 12, 4, 4, 20, 
+        2, 163, 32, 4, 157, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u32_to_u8);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u32_to_u8");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u32_to_u8);
+      orc_program_add_destination (p, 1, "d1");
+      orc_program_add_source (p, 4, "s1");
+      orc_program_add_temporary (p, 2, "t1");
+
+      orc_program_append_2 (p, "convlw", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convwb", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u32_to_s16 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u32_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: convssslw */
+    var33.i = ORC_CLAMP_SW(var32.i);
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u32_to_s16 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: convssslw */
+    var33.i = ORC_CLAMP_SW(var32.i);
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_u32_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 51, 50, 95, 116, 111, 95, 115, 49, 54, 11, 2, 2, 12, 4, 4, 
+        165, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u32_to_s16);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u32_to_s16");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u32_to_s16);
+      orc_program_add_destination (p, 2, "d1");
+      orc_program_add_source (p, 4, "s1");
+
+      orc_program_append_2 (p, "convssslw", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u32_to_u16 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u32_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: convssslw */
+    var33.i = ORC_CLAMP_SW(var32.i);
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u32_to_u16 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union16 var33;
+
+  ptr0 = (orc_union16 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: convssslw */
+    var33.i = ORC_CLAMP_SW(var32.i);
+    /* 2: storew */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_u32_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 51, 50, 95, 116, 111, 95, 117, 49, 54, 11, 2, 2, 12, 4, 4, 
+        165, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u32_to_u16);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u32_to_u16");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u32_to_u16);
+      orc_program_add_destination (p, 2, "d1");
+      orc_program_add_source (p, 4, "s1");
+
+      orc_program_append_2 (p, "convssslw", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u32_to_s32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u32_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: copyl */
+    var33.i = var32.i;
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u32_to_s32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: copyl */
+    var33.i = var32.i;
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_u32_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 51, 50, 95, 116, 111, 95, 115, 51, 50, 11, 4, 4, 12, 4, 4, 
+        112, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u32_to_s32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u32_to_s32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u32_to_s32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 4, "s1");
+
+      orc_program_append_2 (p, "copyl", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u32_to_u32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u32_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: copyl */
+    var33.i = var32.i;
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u32_to_u32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: copyl */
+    var33.i = var32.i;
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_u32_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 51, 50, 95, 116, 111, 95, 117, 51, 50, 11, 4, 4, 12, 4, 4, 
+        112, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u32_to_u32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u32_to_u32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u32_to_u32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 4, "s1");
+
+      orc_program_append_2 (p, "copyl", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u32_to_f32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u32_to_f32 (float * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: convlf */
+    var33.f = var32.i;
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u32_to_f32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: convlf */
+    var33.f = var32.i;
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_u32_to_f32 (float * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 51, 50, 95, 116, 111, 95, 102, 51, 50, 11, 4, 4, 12, 4, 4, 
+        211, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u32_to_f32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u32_to_f32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u32_to_f32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 4, "s1");
+
+      orc_program_append_2 (p, "convlf", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_u32_to_f64 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_u32_to_f64 (double * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union64 var33;
+
+  ptr0 = (orc_union64 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: convld */
+    var33.f = var32.i;
+    /* 2: storeq */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_u32_to_f64 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union64 var33;
+
+  ptr0 = (orc_union64 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: convld */
+    var33.f = var32.i;
+    /* 2: storeq */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_u32_to_f64 (double * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        117, 51, 50, 95, 116, 111, 95, 102, 54, 52, 11, 8, 8, 12, 4, 4, 
+        223, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u32_to_f64);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_u32_to_f64");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_u32_to_f64);
+      orc_program_add_destination (p, 8, "d1");
+      orc_program_add_source (p, 4, "s1");
+
+      orc_program_append_2 (p, "convld", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_add_c_f32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_add_c_f32 (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, float p1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+  orc_union32 var34;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+    /* 1: loadpl */
+    var33.f = p1;
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 2: addf */
+    {
+       orc_union32 _src1;
+       orc_union32 _src2;
+       orc_union32 _dest1;
+       _src1.i = ORC_DENORMAL(var32.i);
+       _src2.i = ORC_DENORMAL(var33.i);
+       _dest1.f = _src1.f + _src2.f;
+       var34.i = ORC_DENORMAL(_dest1.i);
+    }
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_add_c_f32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+  orc_union32 var34;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+    /* 1: loadpl */
+    var33.i = ex->params[24];
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 2: addf */
+    {
+       orc_union32 _src1;
+       orc_union32 _src2;
+       orc_union32 _dest1;
+       _src1.i = ORC_DENORMAL(var32.i);
+       _src2.i = ORC_DENORMAL(var33.i);
+       _dest1.f = _src1.f + _src2.f;
+       var34.i = ORC_DENORMAL(_dest1.i);
+    }
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_add_c_f32 (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, float p1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 17, 110, 110, 115, 95, 111, 114, 99, 95, 97, 100, 100, 95, 99, 
+        95, 102, 51, 50, 11, 4, 4, 12, 4, 4, 17, 4, 200, 0, 4, 24, 
+        2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_add_c_f32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_add_c_f32");
+      orc_program_set_backup_function (p, _backup_nns_orc_add_c_f32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 4, "s1");
+      orc_program_add_parameter_float (p, 4, "p1");
+
+      orc_program_append_2 (p, "addf", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+  {
+    orc_union32 tmp;
+    tmp.f = p1;
+    ex->params[ORC_VAR_P1] = tmp.i;
+  }
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_mul_c_f32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_mul_c_f32 (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, float p1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+  orc_union32 var34;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+    /* 1: loadpl */
+    var33.f = p1;
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 2: mulf */
+    {
+       orc_union32 _src1;
+       orc_union32 _src2;
+       orc_union32 _dest1;
+       _src1.i = ORC_DENORMAL(var32.i);
+       _src2.i = ORC_DENORMAL(var33.i);
+       _dest1.f = _src1.f * _src2.f;
+       var34.i = ORC_DENORMAL(_dest1.i);
+    }
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_mul_c_f32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+  orc_union32 var34;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+    /* 1: loadpl */
+    var33.i = ex->params[24];
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 2: mulf */
+    {
+       orc_union32 _src1;
+       orc_union32 _src2;
+       orc_union32 _dest1;
+       _src1.i = ORC_DENORMAL(var32.i);
+       _src2.i = ORC_DENORMAL(var33.i);
+       _dest1.f = _src1.f * _src2.f;
+       var34.i = ORC_DENORMAL(_dest1.i);
+    }
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_mul_c_f32 (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, float p1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 17, 110, 110, 115, 95, 111, 114, 99, 95, 109, 117, 108, 95, 99, 
+        95, 102, 51, 50, 11, 4, 4, 12, 4, 4, 17, 4, 202, 0, 4, 24, 
+        2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_mul_c_f32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_mul_c_f32");
+      orc_program_set_backup_function (p, _backup_nns_orc_mul_c_f32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 4, "s1");
+      orc_program_add_parameter_float (p, 4, "p1");
+
+      orc_program_append_2 (p, "mulf", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+  {
+    orc_union32 tmp;
+    tmp.f = p1;
+    ex->params[ORC_VAR_P1] = tmp.i;
+  }
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_div_c_f32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_div_c_f32 (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, float p1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+  orc_union32 var34;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+    /* 1: loadpl */
+    var33.f = p1;
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 2: divf */
+    {
+       orc_union32 _src1;
+       orc_union32 _src2;
+       orc_union32 _dest1;
+       _src1.i = ORC_DENORMAL(var32.i);
+       _src2.i = ORC_DENORMAL(var33.i);
+       _dest1.f = _src1.f / _src2.f;
+       var34.i = ORC_DENORMAL(_dest1.i);
+    }
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_div_c_f32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+  orc_union32 var34;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+    /* 1: loadpl */
+    var33.i = ex->params[24];
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 2: divf */
+    {
+       orc_union32 _src1;
+       orc_union32 _src2;
+       orc_union32 _dest1;
+       _src1.i = ORC_DENORMAL(var32.i);
+       _src2.i = ORC_DENORMAL(var33.i);
+       _dest1.f = _src1.f / _src2.f;
+       var34.i = ORC_DENORMAL(_dest1.i);
+    }
+    /* 3: storel */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_div_c_f32 (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, float p1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 17, 110, 110, 115, 95, 111, 114, 99, 95, 100, 105, 118, 95, 99, 
+        95, 102, 51, 50, 11, 4, 4, 12, 4, 4, 17, 4, 203, 0, 4, 24, 
+        2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_div_c_f32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_div_c_f32");
+      orc_program_set_backup_function (p, _backup_nns_orc_div_c_f32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 4, "s1");
+      orc_program_add_parameter_float (p, 4, "p1");
+
+      orc_program_append_2 (p, "divf", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+  {
+    orc_union32 tmp;
+    tmp.f = p1;
+    ex->params[ORC_VAR_P1] = tmp.i;
+  }
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_f32_to_s8 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_f32_to_s8 (orc_int8 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n){
+  int i;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var34;
+  orc_int8 var35;
+  orc_union32 var36;
+  orc_union16 var37;
+
+  ptr0 = (orc_int8 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var34 = ptr4[i];
+    /* 1: convfl */
+    {
+       int tmp;
+       tmp = (int)var34.f;
+       if (tmp == 0x80000000 && !(var34.i&0x80000000)) tmp = 0x7fffffff;
+       var36.i = tmp;
+    }
+    /* 2: convssslw */
+    var37.i = ORC_CLAMP_SW(var36.i);
+    /* 3: convssswb */
+    var35 = ORC_CLAMP_SB(var37.i);
+    /* 4: storeb */
+    ptr0[i] = var35;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_f32_to_s8 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var34;
+  orc_int8 var35;
+  orc_union32 var36;
+  orc_union16 var37;
+
+  ptr0 = (orc_int8 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var34 = ptr4[i];
+    /* 1: convfl */
+    {
+       int tmp;
+       tmp = (int)var34.f;
+       if (tmp == 0x80000000 && !(var34.i&0x80000000)) tmp = 0x7fffffff;
+       var36.i = tmp;
+    }
+    /* 2: convssslw */
+    var37.i = ORC_CLAMP_SW(var36.i);
+    /* 3: convssswb */
+    var35 = ORC_CLAMP_SB(var37.i);
+    /* 4: storeb */
+    ptr0[i] = var35;
+  }
+
+}
+
+void
+nns_orc_conv_f32_to_s8 (orc_int8 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        102, 51, 50, 95, 116, 111, 95, 115, 56, 11, 1, 1, 12, 4, 4, 20, 
+        4, 20, 2, 210, 32, 4, 165, 33, 32, 159, 0, 33, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f32_to_s8);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_f32_to_s8");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f32_to_s8);
+      orc_program_add_destination (p, 1, "d1");
+      orc_program_add_source (p, 4, "s1");
+      orc_program_add_temporary (p, 4, "t1");
+      orc_program_add_temporary (p, 2, "t2");
+
+      orc_program_append_2 (p, "convfl", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convssslw", 0, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_D1, ORC_VAR_T2, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_f32_to_u8 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_f32_to_u8 (orc_uint8 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n){
+  int i;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var34;
+  orc_int8 var35;
+  orc_union32 var36;
+  orc_union16 var37;
+
+  ptr0 = (orc_int8 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var34 = ptr4[i];
+    /* 1: convfl */
+    {
+       int tmp;
+       tmp = (int)var34.f;
+       if (tmp == 0x80000000 && !(var34.i&0x80000000)) tmp = 0x7fffffff;
+       var36.i = tmp;
+    }
+    /* 2: convlw */
+    var37.i = var36.i;
+    /* 3: convwb */
+    var35 = var37.i;
+    /* 4: storeb */
+    ptr0[i] = var35;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_f32_to_u8 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var34;
+  orc_int8 var35;
+  orc_union32 var36;
+  orc_union16 var37;
+
+  ptr0 = (orc_int8 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var34 = ptr4[i];
+    /* 1: convfl */
+    {
+       int tmp;
+       tmp = (int)var34.f;
+       if (tmp == 0x80000000 && !(var34.i&0x80000000)) tmp = 0x7fffffff;
+       var36.i = tmp;
+    }
+    /* 2: convlw */
+    var37.i = var36.i;
+    /* 3: convwb */
+    var35 = var37.i;
+    /* 4: storeb */
+    ptr0[i] = var35;
+  }
+
+}
+
+void
+nns_orc_conv_f32_to_u8 (orc_uint8 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        102, 51, 50, 95, 116, 111, 95, 117, 56, 11, 1, 1, 12, 4, 4, 20, 
+        4, 20, 2, 210, 32, 4, 163, 33, 32, 157, 0, 33, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f32_to_u8);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_f32_to_u8");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f32_to_u8);
+      orc_program_add_destination (p, 1, "d1");
+      orc_program_add_source (p, 4, "s1");
+      orc_program_add_temporary (p, 4, "t1");
+      orc_program_add_temporary (p, 2, "t2");
+
+      orc_program_append_2 (p, "convfl", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convlw", 0, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convwb", 0, ORC_VAR_D1, ORC_VAR_T2, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_f32_to_s16 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_f32_to_s16 (orc_int16 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var33;
+  orc_union16 var34;
+  orc_union32 var35;
+
+  ptr0 = (orc_union16 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var33 = ptr4[i];
+    /* 1: convfl */
+    {
+       int tmp;
+       tmp = (int)var33.f;
+       if (tmp == 0x80000000 && !(var33.i&0x80000000)) tmp = 0x7fffffff;
+       var35.i = tmp;
+    }
+    /* 2: convssslw */
+    var34.i = ORC_CLAMP_SW(var35.i);
+    /* 3: storew */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_f32_to_s16 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var33;
+  orc_union16 var34;
+  orc_union32 var35;
+
+  ptr0 = (orc_union16 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var33 = ptr4[i];
+    /* 1: convfl */
+    {
+       int tmp;
+       tmp = (int)var33.f;
+       if (tmp == 0x80000000 && !(var33.i&0x80000000)) tmp = 0x7fffffff;
+       var35.i = tmp;
+    }
+    /* 2: convssslw */
+    var34.i = ORC_CLAMP_SW(var35.i);
+    /* 3: storew */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_conv_f32_to_s16 (orc_int16 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        102, 51, 50, 95, 116, 111, 95, 115, 49, 54, 11, 2, 2, 12, 4, 4, 
+        20, 4, 210, 32, 4, 165, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f32_to_s16);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_f32_to_s16");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f32_to_s16);
+      orc_program_add_destination (p, 2, "d1");
+      orc_program_add_source (p, 4, "s1");
+      orc_program_add_temporary (p, 4, "t1");
+
+      orc_program_append_2 (p, "convfl", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convssslw", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_f32_to_u16 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_f32_to_u16 (orc_uint16 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var33;
+  orc_union16 var34;
+  orc_union32 var35;
+
+  ptr0 = (orc_union16 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var33 = ptr4[i];
+    /* 1: convfl */
+    {
+       int tmp;
+       tmp = (int)var33.f;
+       if (tmp == 0x80000000 && !(var33.i&0x80000000)) tmp = 0x7fffffff;
+       var35.i = tmp;
+    }
+    /* 2: convssslw */
+    var34.i = ORC_CLAMP_SW(var35.i);
+    /* 3: storew */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_f32_to_u16 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var33;
+  orc_union16 var34;
+  orc_union32 var35;
+
+  ptr0 = (orc_union16 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var33 = ptr4[i];
+    /* 1: convfl */
+    {
+       int tmp;
+       tmp = (int)var33.f;
+       if (tmp == 0x80000000 && !(var33.i&0x80000000)) tmp = 0x7fffffff;
+       var35.i = tmp;
+    }
+    /* 2: convssslw */
+    var34.i = ORC_CLAMP_SW(var35.i);
+    /* 3: storew */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_conv_f32_to_u16 (orc_uint16 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        102, 51, 50, 95, 116, 111, 95, 117, 49, 54, 11, 2, 2, 12, 4, 4, 
+        20, 4, 210, 32, 4, 165, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f32_to_u16);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_f32_to_u16");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f32_to_u16);
+      orc_program_add_destination (p, 2, "d1");
+      orc_program_add_source (p, 4, "s1");
+      orc_program_add_temporary (p, 4, "t1");
+
+      orc_program_append_2 (p, "convfl", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convssslw", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_f32_to_s32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_f32_to_s32 (orc_int32 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: convfl */
+    {
+       int tmp;
+       tmp = (int)var32.f;
+       if (tmp == 0x80000000 && !(var32.i&0x80000000)) tmp = 0x7fffffff;
+       var33.i = tmp;
+    }
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_f32_to_s32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: convfl */
+    {
+       int tmp;
+       tmp = (int)var32.f;
+       if (tmp == 0x80000000 && !(var32.i&0x80000000)) tmp = 0x7fffffff;
+       var33.i = tmp;
+    }
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_f32_to_s32 (orc_int32 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        102, 51, 50, 95, 116, 111, 95, 115, 51, 50, 11, 4, 4, 12, 4, 4, 
+        210, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f32_to_s32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_f32_to_s32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f32_to_s32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 4, "s1");
+
+      orc_program_append_2 (p, "convfl", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_f32_to_u32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_f32_to_u32 (orc_uint32 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: convfl */
+    {
+       int tmp;
+       tmp = (int)var32.f;
+       if (tmp == 0x80000000 && !(var32.i&0x80000000)) tmp = 0x7fffffff;
+       var33.i = tmp;
+    }
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_f32_to_u32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: convfl */
+    {
+       int tmp;
+       tmp = (int)var32.f;
+       if (tmp == 0x80000000 && !(var32.i&0x80000000)) tmp = 0x7fffffff;
+       var33.i = tmp;
+    }
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_f32_to_u32 (orc_uint32 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        102, 51, 50, 95, 116, 111, 95, 117, 51, 50, 11, 4, 4, 12, 4, 4, 
+        210, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f32_to_u32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_f32_to_u32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f32_to_u32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 4, "s1");
+
+      orc_program_append_2 (p, "convfl", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_f32_to_f32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_f32_to_f32 (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: copyl */
+    var33.i = var32.i;
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_f32_to_f32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: copyl */
+    var33.i = var32.i;
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_f32_to_f32 (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        102, 51, 50, 95, 116, 111, 95, 102, 51, 50, 11, 4, 4, 12, 4, 4, 
+        112, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f32_to_f32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_f32_to_f32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f32_to_f32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 4, "s1");
+
+      orc_program_append_2 (p, "copyl", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_f32_to_f64 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_f32_to_f64 (double * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union64 var33;
+
+  ptr0 = (orc_union64 *)d1;
+  ptr4 = (orc_union32 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: convfd */
+    {
+       orc_union32 _src1;
+       _src1.i = ORC_DENORMAL(var32.i);
+       var33.f = _src1.f;
+    }
+    /* 2: storeq */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_f32_to_f64 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_union32 * ORC_RESTRICT ptr4;
+  orc_union32 var32;
+  orc_union64 var33;
+
+  ptr0 = (orc_union64 *)ex->arrays[0];
+  ptr4 = (orc_union32 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadl */
+    var32 = ptr4[i];
+    /* 1: convfd */
+    {
+       orc_union32 _src1;
+       _src1.i = ORC_DENORMAL(var32.i);
+       var33.f = _src1.f;
+    }
+    /* 2: storeq */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_f32_to_f64 (double * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        102, 51, 50, 95, 116, 111, 95, 102, 54, 52, 11, 8, 8, 12, 4, 4, 
+        224, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f32_to_f64);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_f32_to_f64");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f32_to_f64);
+      orc_program_add_destination (p, 8, "d1");
+      orc_program_add_source (p, 4, "s1");
+
+      orc_program_append_2 (p, "convfd", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_add_c_f64 */
+#ifdef DISABLE_ORC
+void
+nns_orc_add_c_f64 (double * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, double p1, int n){
+  int i;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var32;
+  orc_union64 var33;
+  orc_union64 var34;
+
+  ptr0 = (orc_union64 *)d1;
+  ptr4 = (orc_union64 *)s1;
+
+    /* 1: loadpq */
+    var33.f = p1;
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var32 = ptr4[i];
+    /* 2: addd */
+    {
+       orc_union64 _src1;
+       orc_union64 _src2;
+       orc_union64 _dest1;
+       _src1.i = ORC_DENORMAL_DOUBLE(var32.i);
+       _src2.i = ORC_DENORMAL_DOUBLE(var33.i);
+       _dest1.f = _src1.f + _src2.f;
+       var34.i = ORC_DENORMAL_DOUBLE(_dest1.i);
+    }
+    /* 3: storeq */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_add_c_f64 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var32;
+  orc_union64 var33;
+  orc_union64 var34;
+
+  ptr0 = (orc_union64 *)ex->arrays[0];
+  ptr4 = (orc_union64 *)ex->arrays[4];
+
+    /* 1: loadpq */
+    var33.i = (ex->params[24] & 0xffffffff) | ((orc_uint64)(ex->params[24 + (ORC_VAR_T1 - ORC_VAR_P1)]) << 32);
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var32 = ptr4[i];
+    /* 2: addd */
+    {
+       orc_union64 _src1;
+       orc_union64 _src2;
+       orc_union64 _dest1;
+       _src1.i = ORC_DENORMAL_DOUBLE(var32.i);
+       _src2.i = ORC_DENORMAL_DOUBLE(var33.i);
+       _dest1.f = _src1.f + _src2.f;
+       var34.i = ORC_DENORMAL_DOUBLE(_dest1.i);
+    }
+    /* 3: storeq */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_add_c_f64 (double * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, double p1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 17, 110, 110, 115, 95, 111, 114, 99, 95, 97, 100, 100, 95, 99, 
+        95, 102, 54, 52, 11, 8, 8, 12, 8, 8, 18, 8, 212, 0, 4, 24, 
+        2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_add_c_f64);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_add_c_f64");
+      orc_program_set_backup_function (p, _backup_nns_orc_add_c_f64);
+      orc_program_add_destination (p, 8, "d1");
+      orc_program_add_source (p, 8, "s1");
+      orc_program_add_parameter_double (p, 8, "p1");
+
+      orc_program_append_2 (p, "addd", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+  {
+    orc_union64 tmp;
+    tmp.f = p1;
+    ex->params[ORC_VAR_P1] = ((orc_uint64) tmp.i) & 0xffffffff;
+    ex->params[ORC_VAR_T1] = ((orc_uint64) tmp.i) >> 32;
+  }
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_mul_c_f64 */
+#ifdef DISABLE_ORC
+void
+nns_orc_mul_c_f64 (double * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, double p1, int n){
+  int i;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var32;
+  orc_union64 var33;
+  orc_union64 var34;
+
+  ptr0 = (orc_union64 *)d1;
+  ptr4 = (orc_union64 *)s1;
+
+    /* 1: loadpq */
+    var33.f = p1;
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var32 = ptr4[i];
+    /* 2: muld */
+    {
+       orc_union64 _src1;
+       orc_union64 _src2;
+       orc_union64 _dest1;
+       _src1.i = ORC_DENORMAL_DOUBLE(var32.i);
+       _src2.i = ORC_DENORMAL_DOUBLE(var33.i);
+       _dest1.f = _src1.f * _src2.f;
+       var34.i = ORC_DENORMAL_DOUBLE(_dest1.i);
+    }
+    /* 3: storeq */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_mul_c_f64 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var32;
+  orc_union64 var33;
+  orc_union64 var34;
+
+  ptr0 = (orc_union64 *)ex->arrays[0];
+  ptr4 = (orc_union64 *)ex->arrays[4];
+
+    /* 1: loadpq */
+    var33.i = (ex->params[24] & 0xffffffff) | ((orc_uint64)(ex->params[24 + (ORC_VAR_T1 - ORC_VAR_P1)]) << 32);
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var32 = ptr4[i];
+    /* 2: muld */
+    {
+       orc_union64 _src1;
+       orc_union64 _src2;
+       orc_union64 _dest1;
+       _src1.i = ORC_DENORMAL_DOUBLE(var32.i);
+       _src2.i = ORC_DENORMAL_DOUBLE(var33.i);
+       _dest1.f = _src1.f * _src2.f;
+       var34.i = ORC_DENORMAL_DOUBLE(_dest1.i);
+    }
+    /* 3: storeq */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_mul_c_f64 (double * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, double p1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 17, 110, 110, 115, 95, 111, 114, 99, 95, 109, 117, 108, 95, 99, 
+        95, 102, 54, 52, 11, 8, 8, 12, 8, 8, 18, 8, 214, 0, 4, 24, 
+        2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_mul_c_f64);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_mul_c_f64");
+      orc_program_set_backup_function (p, _backup_nns_orc_mul_c_f64);
+      orc_program_add_destination (p, 8, "d1");
+      orc_program_add_source (p, 8, "s1");
+      orc_program_add_parameter_double (p, 8, "p1");
+
+      orc_program_append_2 (p, "muld", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+  {
+    orc_union64 tmp;
+    tmp.f = p1;
+    ex->params[ORC_VAR_P1] = ((orc_uint64) tmp.i) & 0xffffffff;
+    ex->params[ORC_VAR_T1] = ((orc_uint64) tmp.i) >> 32;
+  }
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_div_c_f64 */
+#ifdef DISABLE_ORC
+void
+nns_orc_div_c_f64 (double * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, double p1, int n){
+  int i;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var32;
+  orc_union64 var33;
+  orc_union64 var34;
+
+  ptr0 = (orc_union64 *)d1;
+  ptr4 = (orc_union64 *)s1;
+
+    /* 1: loadpq */
+    var33.f = p1;
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var32 = ptr4[i];
+    /* 2: divd */
+    {
+       orc_union64 _src1;
+       orc_union64 _src2;
+       orc_union64 _dest1;
+       _src1.i = ORC_DENORMAL_DOUBLE(var32.i);
+       _src2.i = ORC_DENORMAL_DOUBLE(var33.i);
+       _dest1.f = _src1.f / _src2.f;
+       var34.i = ORC_DENORMAL_DOUBLE(_dest1.i);
+    }
+    /* 3: storeq */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_div_c_f64 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var32;
+  orc_union64 var33;
+  orc_union64 var34;
+
+  ptr0 = (orc_union64 *)ex->arrays[0];
+  ptr4 = (orc_union64 *)ex->arrays[4];
+
+    /* 1: loadpq */
+    var33.i = (ex->params[24] & 0xffffffff) | ((orc_uint64)(ex->params[24 + (ORC_VAR_T1 - ORC_VAR_P1)]) << 32);
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var32 = ptr4[i];
+    /* 2: divd */
+    {
+       orc_union64 _src1;
+       orc_union64 _src2;
+       orc_union64 _dest1;
+       _src1.i = ORC_DENORMAL_DOUBLE(var32.i);
+       _src2.i = ORC_DENORMAL_DOUBLE(var33.i);
+       _dest1.f = _src1.f / _src2.f;
+       var34.i = ORC_DENORMAL_DOUBLE(_dest1.i);
+    }
+    /* 3: storeq */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_div_c_f64 (double * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, double p1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 17, 110, 110, 115, 95, 111, 114, 99, 95, 100, 105, 118, 95, 99, 
+        95, 102, 54, 52, 11, 8, 8, 12, 8, 8, 18, 8, 215, 0, 4, 24, 
+        2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_div_c_f64);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_div_c_f64");
+      orc_program_set_backup_function (p, _backup_nns_orc_div_c_f64);
+      orc_program_add_destination (p, 8, "d1");
+      orc_program_add_source (p, 8, "s1");
+      orc_program_add_parameter_double (p, 8, "p1");
+
+      orc_program_append_2 (p, "divd", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_P1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+  {
+    orc_union64 tmp;
+    tmp.f = p1;
+    ex->params[ORC_VAR_P1] = ((orc_uint64) tmp.i) & 0xffffffff;
+    ex->params[ORC_VAR_T1] = ((orc_uint64) tmp.i) >> 32;
+  }
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_f64_to_s8 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_f64_to_s8 (orc_int8 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n){
+  int i;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var34;
+  orc_int8 var35;
+  orc_union32 var36;
+  orc_union16 var37;
+
+  ptr0 = (orc_int8 *)d1;
+  ptr4 = (orc_union64 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var34 = ptr4[i];
+    /* 1: convdl */
+    {
+       int tmp;
+       tmp = var34.f;
+       if (tmp == 0x80000000 && !(var34.i & ORC_UINT64_C(0x8000000000000000))) tmp = 0x7fffffff;
+       var36.i = tmp;
+    }
+    /* 2: convssslw */
+    var37.i = ORC_CLAMP_SW(var36.i);
+    /* 3: convssswb */
+    var35 = ORC_CLAMP_SB(var37.i);
+    /* 4: storeb */
+    ptr0[i] = var35;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_f64_to_s8 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var34;
+  orc_int8 var35;
+  orc_union32 var36;
+  orc_union16 var37;
+
+  ptr0 = (orc_int8 *)ex->arrays[0];
+  ptr4 = (orc_union64 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var34 = ptr4[i];
+    /* 1: convdl */
+    {
+       int tmp;
+       tmp = var34.f;
+       if (tmp == 0x80000000 && !(var34.i & ORC_UINT64_C(0x8000000000000000))) tmp = 0x7fffffff;
+       var36.i = tmp;
+    }
+    /* 2: convssslw */
+    var37.i = ORC_CLAMP_SW(var36.i);
+    /* 3: convssswb */
+    var35 = ORC_CLAMP_SB(var37.i);
+    /* 4: storeb */
+    ptr0[i] = var35;
+  }
+
+}
+
+void
+nns_orc_conv_f64_to_s8 (orc_int8 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        102, 54, 52, 95, 116, 111, 95, 115, 56, 11, 1, 1, 12, 8, 8, 20, 
+        4, 20, 2, 222, 32, 4, 165, 33, 32, 159, 0, 33, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f64_to_s8);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_f64_to_s8");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f64_to_s8);
+      orc_program_add_destination (p, 1, "d1");
+      orc_program_add_source (p, 8, "s1");
+      orc_program_add_temporary (p, 4, "t1");
+      orc_program_add_temporary (p, 2, "t2");
+
+      orc_program_append_2 (p, "convdl", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convssslw", 0, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convssswb", 0, ORC_VAR_D1, ORC_VAR_T2, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_f64_to_u8 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_f64_to_u8 (orc_uint8 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n){
+  int i;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var34;
+  orc_int8 var35;
+  orc_union32 var36;
+  orc_union16 var37;
+
+  ptr0 = (orc_int8 *)d1;
+  ptr4 = (orc_union64 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var34 = ptr4[i];
+    /* 1: convdl */
+    {
+       int tmp;
+       tmp = var34.f;
+       if (tmp == 0x80000000 && !(var34.i & ORC_UINT64_C(0x8000000000000000))) tmp = 0x7fffffff;
+       var36.i = tmp;
+    }
+    /* 2: convlw */
+    var37.i = var36.i;
+    /* 3: convwb */
+    var35 = var37.i;
+    /* 4: storeb */
+    ptr0[i] = var35;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_f64_to_u8 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_int8 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var34;
+  orc_int8 var35;
+  orc_union32 var36;
+  orc_union16 var37;
+
+  ptr0 = (orc_int8 *)ex->arrays[0];
+  ptr4 = (orc_union64 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var34 = ptr4[i];
+    /* 1: convdl */
+    {
+       int tmp;
+       tmp = var34.f;
+       if (tmp == 0x80000000 && !(var34.i & ORC_UINT64_C(0x8000000000000000))) tmp = 0x7fffffff;
+       var36.i = tmp;
+    }
+    /* 2: convlw */
+    var37.i = var36.i;
+    /* 3: convwb */
+    var35 = var37.i;
+    /* 4: storeb */
+    ptr0[i] = var35;
+  }
+
+}
+
+void
+nns_orc_conv_f64_to_u8 (orc_uint8 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 22, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        102, 54, 52, 95, 116, 111, 95, 117, 56, 11, 1, 1, 12, 8, 8, 20, 
+        4, 20, 2, 222, 32, 4, 163, 33, 32, 157, 0, 33, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f64_to_u8);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_f64_to_u8");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f64_to_u8);
+      orc_program_add_destination (p, 1, "d1");
+      orc_program_add_source (p, 8, "s1");
+      orc_program_add_temporary (p, 4, "t1");
+      orc_program_add_temporary (p, 2, "t2");
+
+      orc_program_append_2 (p, "convdl", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convlw", 0, ORC_VAR_T2, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convwb", 0, ORC_VAR_D1, ORC_VAR_T2, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_f64_to_s16 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_f64_to_s16 (orc_int16 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var33;
+  orc_union16 var34;
+  orc_union32 var35;
+
+  ptr0 = (orc_union16 *)d1;
+  ptr4 = (orc_union64 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var33 = ptr4[i];
+    /* 1: convdl */
+    {
+       int tmp;
+       tmp = var33.f;
+       if (tmp == 0x80000000 && !(var33.i & ORC_UINT64_C(0x8000000000000000))) tmp = 0x7fffffff;
+       var35.i = tmp;
+    }
+    /* 2: convssslw */
+    var34.i = ORC_CLAMP_SW(var35.i);
+    /* 3: storew */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_f64_to_s16 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var33;
+  orc_union16 var34;
+  orc_union32 var35;
+
+  ptr0 = (orc_union16 *)ex->arrays[0];
+  ptr4 = (orc_union64 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var33 = ptr4[i];
+    /* 1: convdl */
+    {
+       int tmp;
+       tmp = var33.f;
+       if (tmp == 0x80000000 && !(var33.i & ORC_UINT64_C(0x8000000000000000))) tmp = 0x7fffffff;
+       var35.i = tmp;
+    }
+    /* 2: convssslw */
+    var34.i = ORC_CLAMP_SW(var35.i);
+    /* 3: storew */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_conv_f64_to_s16 (orc_int16 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        102, 54, 52, 95, 116, 111, 95, 115, 49, 54, 11, 2, 2, 12, 8, 8, 
+        20, 4, 222, 32, 4, 165, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f64_to_s16);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_f64_to_s16");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f64_to_s16);
+      orc_program_add_destination (p, 2, "d1");
+      orc_program_add_source (p, 8, "s1");
+      orc_program_add_temporary (p, 4, "t1");
+
+      orc_program_append_2 (p, "convdl", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convssslw", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_f64_to_u16 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_f64_to_u16 (orc_uint16 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var33;
+  orc_union16 var34;
+  orc_union32 var35;
+
+  ptr0 = (orc_union16 *)d1;
+  ptr4 = (orc_union64 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var33 = ptr4[i];
+    /* 1: convdl */
+    {
+       int tmp;
+       tmp = var33.f;
+       if (tmp == 0x80000000 && !(var33.i & ORC_UINT64_C(0x8000000000000000))) tmp = 0x7fffffff;
+       var35.i = tmp;
+    }
+    /* 2: convssslw */
+    var34.i = ORC_CLAMP_SW(var35.i);
+    /* 3: storew */
+    ptr0[i] = var34;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_f64_to_u16 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union16 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var33;
+  orc_union16 var34;
+  orc_union32 var35;
+
+  ptr0 = (orc_union16 *)ex->arrays[0];
+  ptr4 = (orc_union64 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var33 = ptr4[i];
+    /* 1: convdl */
+    {
+       int tmp;
+       tmp = var33.f;
+       if (tmp == 0x80000000 && !(var33.i & ORC_UINT64_C(0x8000000000000000))) tmp = 0x7fffffff;
+       var35.i = tmp;
+    }
+    /* 2: convssslw */
+    var34.i = ORC_CLAMP_SW(var35.i);
+    /* 3: storew */
+    ptr0[i] = var34;
+  }
+
+}
+
+void
+nns_orc_conv_f64_to_u16 (orc_uint16 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        102, 54, 52, 95, 116, 111, 95, 117, 49, 54, 11, 2, 2, 12, 8, 8, 
+        20, 4, 222, 32, 4, 165, 0, 32, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f64_to_u16);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_f64_to_u16");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f64_to_u16);
+      orc_program_add_destination (p, 2, "d1");
+      orc_program_add_source (p, 8, "s1");
+      orc_program_add_temporary (p, 4, "t1");
+
+      orc_program_append_2 (p, "convdl", 0, ORC_VAR_T1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+      orc_program_append_2 (p, "convssslw", 0, ORC_VAR_D1, ORC_VAR_T1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_f64_to_s32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_f64_to_s32 (orc_int32 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union64 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var32 = ptr4[i];
+    /* 1: convdl */
+    {
+       int tmp;
+       tmp = var32.f;
+       if (tmp == 0x80000000 && !(var32.i & ORC_UINT64_C(0x8000000000000000))) tmp = 0x7fffffff;
+       var33.i = tmp;
+    }
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_f64_to_s32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union64 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var32 = ptr4[i];
+    /* 1: convdl */
+    {
+       int tmp;
+       tmp = var32.f;
+       if (tmp == 0x80000000 && !(var32.i & ORC_UINT64_C(0x8000000000000000))) tmp = 0x7fffffff;
+       var33.i = tmp;
+    }
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_f64_to_s32 (orc_int32 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        102, 54, 52, 95, 116, 111, 95, 115, 51, 50, 11, 4, 4, 12, 8, 8, 
+        222, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f64_to_s32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_f64_to_s32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f64_to_s32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 8, "s1");
+
+      orc_program_append_2 (p, "convdl", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_f64_to_u32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_f64_to_u32 (orc_uint32 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union64 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var32 = ptr4[i];
+    /* 1: convdl */
+    {
+       int tmp;
+       tmp = var32.f;
+       if (tmp == 0x80000000 && !(var32.i & ORC_UINT64_C(0x8000000000000000))) tmp = 0x7fffffff;
+       var33.i = tmp;
+    }
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_f64_to_u32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union64 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var32 = ptr4[i];
+    /* 1: convdl */
+    {
+       int tmp;
+       tmp = var32.f;
+       if (tmp == 0x80000000 && !(var32.i & ORC_UINT64_C(0x8000000000000000))) tmp = 0x7fffffff;
+       var33.i = tmp;
+    }
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_f64_to_u32 (orc_uint32 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        102, 54, 52, 95, 116, 111, 95, 117, 51, 50, 11, 4, 4, 12, 8, 8, 
+        222, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f64_to_u32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_f64_to_u32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f64_to_u32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 8, "s1");
+
+      orc_program_append_2 (p, "convdl", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_f64_to_f32 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_f64_to_f32 (float * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)d1;
+  ptr4 = (orc_union64 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var32 = ptr4[i];
+    /* 1: convdf */
+    {
+       orc_union64 _src1;
+       orc_union32 _dest;
+       _src1.i = ORC_DENORMAL_DOUBLE(var32.i);
+       _dest.f = _src1.f;
+       var33.i = ORC_DENORMAL(_dest.i);
+    }
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_f64_to_f32 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union32 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var32;
+  orc_union32 var33;
+
+  ptr0 = (orc_union32 *)ex->arrays[0];
+  ptr4 = (orc_union64 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var32 = ptr4[i];
+    /* 1: convdf */
+    {
+       orc_union64 _src1;
+       orc_union32 _dest;
+       _src1.i = ORC_DENORMAL_DOUBLE(var32.i);
+       _dest.f = _src1.f;
+       var33.i = ORC_DENORMAL(_dest.i);
+    }
+    /* 2: storel */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_f64_to_f32 (float * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        102, 54, 52, 95, 116, 111, 95, 102, 51, 50, 11, 4, 4, 12, 8, 8, 
+        225, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f64_to_f32);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_f64_to_f32");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f64_to_f32);
+      orc_program_add_destination (p, 4, "d1");
+      orc_program_add_source (p, 8, "s1");
+
+      orc_program_append_2 (p, "convdf", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
+/* nns_orc_conv_f64_to_f64 */
+#ifdef DISABLE_ORC
+void
+nns_orc_conv_f64_to_f64 (double * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n){
+  int i;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var32;
+  orc_union64 var33;
+
+  ptr0 = (orc_union64 *)d1;
+  ptr4 = (orc_union64 *)s1;
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var32 = ptr4[i];
+    /* 1: copyq */
+    var33.i = var32.i;
+    /* 2: storeq */
+    ptr0[i] = var33;
+  }
+
+}
+
+#else
+static void
+_backup_nns_orc_conv_f64_to_f64 (OrcExecutor * ORC_RESTRICT ex)
+{
+  int i;
+  int n = ex->n;
+  orc_union64 * ORC_RESTRICT ptr0;
+  const orc_union64 * ORC_RESTRICT ptr4;
+  orc_union64 var32;
+  orc_union64 var33;
+
+  ptr0 = (orc_union64 *)ex->arrays[0];
+  ptr4 = (orc_union64 *)ex->arrays[4];
+
+
+  for (i = 0; i < n; i++) {
+    /* 0: loadq */
+    var32 = ptr4[i];
+    /* 1: copyq */
+    var33.i = var32.i;
+    /* 2: storeq */
+    ptr0[i] = var33;
+  }
+
+}
+
+void
+nns_orc_conv_f64_to_f64 (double * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n)
+{
+  OrcExecutor _ex, *ex = &_ex;
+  static volatile int p_inited = 0;
+  static OrcCode *c = 0;
+  void (*func) (OrcExecutor *);
+
+  if (!p_inited) {
+    orc_once_mutex_lock ();
+    if (!p_inited) {
+      OrcProgram *p;
+
+#if 1
+      static const orc_uint8 bc[] = {
+        1, 9, 23, 110, 110, 115, 95, 111, 114, 99, 95, 99, 111, 110, 118, 95, 
+        102, 54, 52, 95, 116, 111, 95, 102, 54, 52, 11, 8, 8, 12, 8, 8, 
+        137, 0, 4, 2, 0, 
+      };
+      p = orc_program_new_from_static_bytecode (bc);
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f64_to_f64);
+#else
+      p = orc_program_new ();
+      orc_program_set_name (p, "nns_orc_conv_f64_to_f64");
+      orc_program_set_backup_function (p, _backup_nns_orc_conv_f64_to_f64);
+      orc_program_add_destination (p, 8, "d1");
+      orc_program_add_source (p, 8, "s1");
+
+      orc_program_append_2 (p, "copyq", 0, ORC_VAR_D1, ORC_VAR_S1, ORC_VAR_D1, ORC_VAR_D1);
+#endif
+
+      orc_program_compile (p);
+      c = orc_program_take_code (p);
+      orc_program_free (p);
+    }
+    p_inited = TRUE;
+    orc_once_mutex_unlock ();
+  }
+  ex->arrays[ORC_VAR_A2] = c;
+  ex->program = 0;
+
+  ex->n = n;
+  ex->arrays[ORC_VAR_D1] = d1;
+  ex->arrays[ORC_VAR_S1] = (void *)s1;
+
+  func = c->exec;
+  func (ex);
+}
+#endif
+
+
diff --git a/gst/nnstreamer/tensor_transform/transform-orc.h b/gst/nnstreamer/tensor_transform/transform-orc.h
new file mode 100644
index 0000000..b76b77e
--- /dev/null
+++ b/gst/nnstreamer/tensor_transform/transform-orc.h
@@ -0,0 +1,171 @@
+
+/* autogenerated from transform-orc.orc */
+
+#ifndef __HOME_JIJOONGMOON_WORKSPACE1_NNSUITE_NNSTREAMER_GST_NNSTREAMER_TENSOR_TRANSFORM_TRANSFORM_ORC_H_
+#define __HOME_JIJOONGMOON_WORKSPACE1_NNSUITE_NNSTREAMER_GST_NNSTREAMER_TENSOR_TRANSFORM_TRANSFORM_ORC_H_
+
+#include <glib.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+#ifndef _ORC_INTEGER_TYPEDEFS_
+#define _ORC_INTEGER_TYPEDEFS_
+#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+#include <stdint.h>
+typedef int8_t orc_int8;
+typedef int16_t orc_int16;
+typedef int32_t orc_int32;
+typedef int64_t orc_int64;
+typedef uint8_t orc_uint8;
+typedef uint16_t orc_uint16;
+typedef uint32_t orc_uint32;
+typedef uint64_t orc_uint64;
+#define ORC_UINT64_C(x) UINT64_C(x)
+#elif defined(_MSC_VER)
+typedef signed __int8 orc_int8;
+typedef signed __int16 orc_int16;
+typedef signed __int32 orc_int32;
+typedef signed __int64 orc_int64;
+typedef unsigned __int8 orc_uint8;
+typedef unsigned __int16 orc_uint16;
+typedef unsigned __int32 orc_uint32;
+typedef unsigned __int64 orc_uint64;
+#define ORC_UINT64_C(x) (x##Ui64)
+#define inline __inline
+#else
+#include <limits.h>
+typedef signed char orc_int8;
+typedef short orc_int16;
+typedef int orc_int32;
+typedef unsigned char orc_uint8;
+typedef unsigned short orc_uint16;
+typedef unsigned int orc_uint32;
+#if INT_MAX == LONG_MAX
+typedef long long orc_int64;
+typedef unsigned long long orc_uint64;
+#define ORC_UINT64_C(x) (x##ULL)
+#else
+typedef long orc_int64;
+typedef unsigned long orc_uint64;
+#define ORC_UINT64_C(x) (x##UL)
+#endif
+#endif
+typedef union { orc_int16 i; orc_int8 x2[2]; } orc_union16;
+typedef union { orc_int32 i; float f; orc_int16 x2[2]; orc_int8 x4[4]; } orc_union32;
+typedef union { orc_int64 i; double f; orc_int32 x2[2]; float x2f[2]; orc_int16 x4[4]; } orc_union64;
+#endif
+#ifndef ORC_RESTRICT
+#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+#define ORC_RESTRICT restrict
+#elif defined(__GNUC__) && __GNUC__ >= 4
+#define ORC_RESTRICT __restrict__
+#else
+#define ORC_RESTRICT
+#endif
+#endif
+
+#ifndef ORC_INTERNAL
+#if defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590)
+#define ORC_INTERNAL __attribute__((visibility("hidden")))
+#elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
+#define ORC_INTERNAL __hidden
+#elif defined (__GNUC__)
+#define ORC_INTERNAL __attribute__((visibility("hidden")))
+#else
+#define ORC_INTERNAL
+#endif
+#endif
+
+void nns_orc_add_c_s8 (orc_int8 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_mul_c_s8 (orc_int8 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_conv_s8_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s8_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s8_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s8_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s8_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s8_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s8_to_f32 (float * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s8_to_f64 (double * ORC_RESTRICT d1, const orc_int8 * ORC_RESTRICT s1, int n);
+void nns_orc_add_c_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_mul_c_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_conv_u8_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u8_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u8_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u8_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u8_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u8_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u8_to_f32 (float * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u8_to_f64 (double * ORC_RESTRICT d1, const orc_uint8 * ORC_RESTRICT s1, int n);
+void nns_orc_add_c_s16 (orc_int16 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_mul_c_s16 (orc_int16 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_conv_s16_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s16_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s16_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s16_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s16_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s16_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s16_to_f32 (float * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s16_to_f64 (double * ORC_RESTRICT d1, const orc_int16 * ORC_RESTRICT s1, int n);
+void nns_orc_add_c_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_mul_c_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_conv_u16_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u16_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u16_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u16_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u16_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u16_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u16_to_f32 (float * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u16_to_f64 (double * ORC_RESTRICT d1, const orc_uint16 * ORC_RESTRICT s1, int n);
+void nns_orc_add_c_s32 (orc_int32 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_mul_c_s32 (orc_int32 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_conv_s32_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s32_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s32_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s32_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s32_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s32_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s32_to_f32 (float * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_s32_to_f64 (double * ORC_RESTRICT d1, const orc_int32 * ORC_RESTRICT s1, int n);
+void nns_orc_add_c_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_mul_c_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int p1, int n);
+void nns_orc_conv_u32_to_s8 (orc_int8 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u32_to_u8 (orc_uint8 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u32_to_s16 (orc_int16 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u32_to_u16 (orc_uint16 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u32_to_s32 (orc_int32 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u32_to_u32 (orc_uint32 * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u32_to_f32 (float * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n);
+void nns_orc_conv_u32_to_f64 (double * ORC_RESTRICT d1, const orc_uint32 * ORC_RESTRICT s1, int n);
+void nns_orc_add_c_f32 (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, float p1, int n);
+void nns_orc_mul_c_f32 (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, float p1, int n);
+void nns_orc_div_c_f32 (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, float p1, int n);
+void nns_orc_conv_f32_to_s8 (orc_int8 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f32_to_u8 (orc_uint8 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f32_to_s16 (orc_int16 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f32_to_u16 (orc_uint16 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f32_to_s32 (orc_int32 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f32_to_u32 (orc_uint32 * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f32_to_f32 (float * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f32_to_f64 (double * ORC_RESTRICT d1, const float * ORC_RESTRICT s1, int n);
+void nns_orc_add_c_f64 (double * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, double p1, int n);
+void nns_orc_mul_c_f64 (double * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, double p1, int n);
+void nns_orc_div_c_f64 (double * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, double p1, int n);
+void nns_orc_conv_f64_to_s8 (orc_int8 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f64_to_u8 (orc_uint8 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f64_to_s16 (orc_int16 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f64_to_u16 (orc_uint16 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f64_to_s32 (orc_int32 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f64_to_u32 (orc_uint32 * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f64_to_f32 (float * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n);
+void nns_orc_conv_f64_to_f64 (double * ORC_RESTRICT d1, const double * ORC_RESTRICT s1, int n);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/gst/nnstreamer/tensor_typedef.h b/gst/nnstreamer/tensor_typedef.h
index 1d9b25a..9c5e988 100644
--- a/gst/nnstreamer/tensor_typedef.h
+++ b/gst/nnstreamer/tensor_typedef.h
@@ -31,53 +31,11 @@
 #include <stddef.h>
 #include <stdint.h>
 
-/**
- * @brief This value, 16, can be checked with gst_buffer_get_max_memory(),
- * which is GST_BUFFER_MEM_MAX in gstreamer/gstbuffer.c.
- * We redefined the value because GST_BUFFER_MEM_MAX is not exported and
- * we need static value. To modify (increase) this value, you need to update
- * gstreamer/gstbuffer.c as well.
- */
-#define GST_TENSOR_NUM_TENSORS_RANGE "(int) [ 1, " NNS_TENSOR_SIZE_LIMIT_STR " ]"
-#define GST_TENSOR_RATE_RANGE "(fraction) [ 0, max ]"
-/**
- * @brief Fixed size of string type
- */
-#define GST_TENSOR_STRING_SIZE (1024)
 #define NNS_TENSOR_RANK_LIMIT	(4)
 #define NNS_TENSOR_SIZE_LIMIT	(16)
 #define NNS_TENSOR_SIZE_LIMIT_STR	"16"
 #define NNS_TENSOR_DIM_NULL ({0, 0, 0, 0})
 
-
-/**
- * @brief Default static capibility for other/tensor
- */
-#define GST_TENSOR_CAP_DEFAULT \
-    "other/tensor, " \
-    "framerate = " GST_TENSOR_RATE_RANGE
-    /**
-     * type should be one of types in GST_TENSOR_TYPE_ALL
-     * "type = (string) uint8"
-     * dimension shoule be a formatted string with rank NNS_TENSOR_RANK_LIMIT
-     * "dimension = (string) dim1:dim2:dim3:dim4"
-     */
-
-/**
- * @brief Default static capibility for other/tensors
- */
-#define GST_TENSORS_CAP_DEFAULT \
-    "other/tensors, " \
-    "num_tensors = " GST_TENSOR_NUM_TENSORS_RANGE ", "\
-    "framerate = " GST_TENSOR_RATE_RANGE
-    /**
-     * type should be one of types in GST_TENSOR_TYPE_ALL
-     * "types = (string) uint8, uint8, uint8"
-     * Dimensions of Tensors for negotiation. It's comment out here,
-       but when we call gst_structure_get_string, it actually is working well
-     * "dimensions = (string) dim1:dim2:dim3:dim4, dim1:dim2:dim3:dim4"
-     */
-
 /**
  * @brief Possible data element types of other/tensor.
  */
@@ -98,22 +56,6 @@ typedef enum _nns_tensor_type
 } tensor_type;
 
 /**
- * @brief Possible input stream types for other/tensor.
- *
- * This is realted with media input stream to other/tensor.
- * There is no restrictions for the outputs.
- */
-typedef enum _nns_media_type
-{
-  _NNS_VIDEO = 0, /**< supposedly video/x-raw */
-  _NNS_AUDIO, /**< supposedly audio/x-raw */
-  _NNS_STRING, /**< supposedly text/x-raw */
-  _NNS_OCTET, /**< supposedly application/octet-stream */
-
-  _NNS_MEDIA_END, /**< End Marker */
-} media_type;
-
-/**
  * @brief Byte-per-element of each tensor element type.
  */
 static const unsigned int tensor_element_size[] = {
@@ -179,28 +121,6 @@ typedef struct
 } GstTensorsInfo;
 
 /**
- * @brief Internal data structure for configured tensor info (for other/tensor).
- */
-typedef struct
-{
-  GstTensorInfo info; /**< tensor info*/
-  int32_t rate_n; /**< framerate is in fraction, which is numerator/denominator */
-  int32_t rate_d; /**< framerate is in fraction, which is numerator/denominator */
-} GstTensorConfig;
-
-/**
- * @brief Internal data structure for configured tensors info (for other/tensors).
- */
-typedef struct
-{
-  GstTensorsInfo info; /**< tensor info*/
-  int32_t rate_n; /**< framerate is in fraction, which is numerator/denominator */
-  int32_t rate_d; /**< framerate is in fraction, which is numerator/denominator */
-} GstTensorsConfig;
-
-
-/** @todo Separate headers per subplugin-category */
-/**
  * @brief GstTensorFilter's properties for NN framework (internal data structure)
  *
  * Because custom filters of tensor_filter may need to access internal data
@@ -221,97 +141,4 @@ typedef struct _GstTensorFilterProperties
   const char *custom_properties; /**< sub-plugin specific custom property values in string */
 } GstTensorFilterProperties;
 
-/**
- * @brief Tensor_Filter Subplugin definition
- *
- * Common callback parameters:
- * filter Filter properties. Read Only
- * private_data Subplugin's private data. Set this (*private_data = XXX) if you want to change filter->private_data
- */
-typedef struct _GstTensorFilterFramework
-{
-  char *name; /**< Name of the neural network framework, searchable by FRAMEWORK property */
-  int allow_in_place; /**< TRUE(nonzero) if InPlace transfer of input-to-output is allowed. Not supported in main, yet */
-  int allocate_in_invoke; /**< TRUE(nonzero) if invoke_NN is going to allocate outputptr by itself and return the address via outputptr. Do not change this value after cap negotiation is complete (or the stream has been started). */
-
-  int (*invoke_NN) (const GstTensorFilterProperties * prop, void **private_data,
-      const GstTensorMemory * input, GstTensorMemory * output);
-      /**< Mandatory callback. Invoke the given network model.
-       *
-       * @param[in] prop read-only property values
-       * @param[in/out] private_data A subplugin may save its internal private data here. The subplugin is responsible for alloc/free of this pointer.
-       * @param[in] input The array of input tensors. Allocated and filled by tensor_filter/main
-       * @param[out] output The array of output tensors. Allocated by tensor_filter/main and to be filled by invoke_NN. If allocate_in_invoke is TRUE, sub-plugin should allocate the memory block for output tensor. (data in GstTensorMemory)
-       * @return 0 if OK. non-zero if error.
-       */
-
-  int (*getInputDimension) (const GstTensorFilterProperties * prop,
-      void **private_data, GstTensorsInfo * info);
-      /**< Optional. Set NULL if not supported. Get dimension of input tensor
-       * If getInputDimension is NULL, setInputDimension must be defined.
-       * If getInputDimension is defined, it is recommended to define getOutputDimension
-       *
-       * @param[in] prop read-only property values
-       * @param[in/out] private_data A subplugin may save its internal private data here. The subplugin is responsible for alloc/free of this pointer.
-       * @param[out] info structure of tensor info (return value)
-       * @return the size of input tensors
-       */
-
-  int (*getOutputDimension) (const GstTensorFilterProperties * prop,
-      void **private_data, GstTensorsInfo * info);
-      /**< Optional. Set NULL if not supported. Get dimension of output tensor
-       * If getInputDimension is NULL, setInputDimension must be defined.
-       * If getInputDimension is defined, it is recommended to define getOutputDimension
-       *
-       * @param[in] prop read-only property values
-       * @param[in/out] private_data A subplugin may save its internal private data here. The subplugin is responsible for alloc/free of this pointer.
-       * @param[out] info structure of tensor info (return value)
-       * @return the size of output tensors
-       */
-
-  int (*setInputDimension) (const GstTensorFilterProperties * prop,
-      void **private_data, const GstTensorsInfo * in_info,
-      GstTensorsInfo * out_info);
-      /**< Optional. Set Null if not supported. Tensor_filter::main will
-       * configure input dimension from pad-cap in run-time for the sub-plugin.
-       * Then, the sub-plugin is required to return corresponding output dimension
-       * If this is NULL, both getInput/OutputDimension must be non-NULL.
-       *
-       * When you use this, do NOT allocate or fix internal data structure based on it
-       * until invoke is called. Gstreamer may try different dimensions before
-       * settling down.
-       *
-       * @param[in] prop read-only property values
-       * @param[in/out] private_data A subplugin may save its internal private data here. The subplugin is responsible for alloc/free of this pointer.
-       * @param[in] in_info structure of input tensor info
-       * @param[out] out_info structure of output tensor info (return value)
-       * @return 0 if OK. non-zero if error.
-       */
-
-  int (*open) (const GstTensorFilterProperties * prop, void **private_data);
-      /**< Optional. tensor_filter.c will call this before any of other callbacks and will call once before calling close
-       *
-       * @param[in] prop read-only property values
-       * @param[in/out] private_data A subplugin may save its internal private data here. The subplugin is responsible for alloc/free of this pointer. Normally, open() allocates memory for private_data.
-       * @return 0 if ok. < 0 if error.
-       */
-
-  void (*close) (const GstTensorFilterProperties * prop, void **private_data);
-      /**< Optional. tensor_filter.c will not call other callbacks after calling close. Free-ing private_data is this function's responsibility. Set NULL after that.
-       *
-       * @param[in] prop read-only property values
-       * @param[in/out] private_data A subplugin may save its internal private data here. The subplugin is responsible for alloc/free of this pointer. Normally, close() frees private_data and set NULL.
-       */
-
-  void (*destroyNotify) (void * data);
-      /**< Optional. tensor_filter.c will call it when 'allocate_in_invoke' flag of the framework is TRUE. Basically, it is called when the data element is destroyed. If it's set as NULL, g_free() will be used as a default. It will be helpful when the data pointer is included as an object of a nnfw. For instance, if the data pointer is removed when the object is gone, it occurs error. In this case, the objects should be maintained for a while first and destroyed when the data pointer is destroyed. Those kinds of logic could be defined at this method.
-       *
-       * @param[in] data the data element.
-       */
-} GstTensorFilterFramework;
-
-/* extern functions for subplugin management, exist in tensor_filter.c */
-extern int tensor_filter_probe (GstTensorFilterFramework *tfsp);
-extern void tensor_filter_exit (const char *name);
-
 #endif /*__GST_TENSOR_TYPEDEF_H__*/
diff --git a/jni/Android.mk b/jni/Android.mk
new file mode 100644
index 0000000..337186b
--- /dev/null
+++ b/jni/Android.mk
@@ -0,0 +1,401 @@
+LOCAL_PATH := $(call my-dir)
+
+SHARED_HOME := /work/taos/gst-android/gst_root_android-custom-1.12.4-ndkr12b-20190213-0900-decompress-runtime/arm64/
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstreamer-1.0
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libgstreamer-1.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstbase-1.0
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libgstbase-1.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstaudio-1.0
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libgstaudio-1.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstvideo-1.0
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libgstvideo-1.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := glib-2.0
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libglib-2.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gobject-2.0
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libgobject-2.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := intl
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libintl.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := z
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libz.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := bz2
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libbz2.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstcoreelements
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstcoreelements.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstcoretracers
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstcoretracers.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstadder
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstadder.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := orc
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/liborc-0.4.so 
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstapp
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstapp.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstaudioconvert
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstaudioconvert.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstaudiomixer
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstaudiomixer.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstaudiorate
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstaudiorate.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstaudioresample
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstaudioresample.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstaudiotestsrc
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstaudiotestsrc.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstgio
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstgio.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstpango
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstpango.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstrawparse
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstrawparse.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gsttypefindfunctions
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgsttypefindfunctions.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstvideoconvert
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstvideoconvert.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstvideorate
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstvideorate.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstvideoscale
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstvideoscale.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstvideotestsrc
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstvideotestsrc.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstvolume
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstvolume.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstautodetect
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstautodetect.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstvideofilter
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstvideofilter.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstopengl
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstopengl.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstopensles
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstopensles.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gmodule-2.0
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libgmodule-2.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstcompositor
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstcompositor.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := ffi
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libffi.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := tag-1.0
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libgsttag-1.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := iconv
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libiconv.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := app-1.0
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libgstapp-1.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := png
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libpng16.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstpng
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstpng.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := badaudio
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libgstbadaudio-1.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := badbase-1.0
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libgstbadbase-1.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gio-2.0
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libgio-2.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := pangocairo
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libpangocairo-1.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := pangoft2
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libpangoft2-1.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := pango
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libpango-1.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gthread
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libgthread-2.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := cairo
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libcairo.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := pixman
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libpixman-1.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := fontconfig
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libfontconfig.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := expat
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libexpat.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := freetype
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libfreetype.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstbadvideo
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libgstbadvideo-1.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstcontroller
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libgstcontroller-1.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := jpeg
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libjpeg.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := graphene
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libgraphene-1.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstpbutils
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libgstpbutils-1.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstgl
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libgstgl-1.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstbadallocators
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libgstbadallocators-1.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gstallocators
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libgstallocators-1.0.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := harfbuzz
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/libharfbuzz.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := multifile
+LOCAL_SRC_FILES := $(SHARED_HOME)/lib/gstreamer-1.0/libgstmultifile.so
+include $(PREBUILT_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+
+#TARGET_ARCH_ABI := arm64-v8a
+
+LOCAL_ARM_NEON := true
+LOCAL_CFLAGS += -Ofast -mcpu=cortex-a53 -Ilz4-nougat/lib
+LOCAL_CXXFLAGS += -std=c++11
+LOCAL_CFLAGS += -pthread -fopenmp
+
+LOCAL_LDFLAGS += -fuse-ld=bfd
+LOCAL_MODULE_TAGS := optional
+LOCAL_ARM_MODE := arm
+
+LOCAL_MODULE	:= nnstreamer
+NNSTREAMER_GST_HOME := ../gst/nnstreamer
+NNSTREAMER_GST_TEST := ../nnstreamer_example/
+LOCAL_SRC_FILES := $(NNSTREAMER_GST_HOME)/nnstreamer.c \
+	$(NNSTREAMER_GST_HOME)/nnstreamer_conf.c \
+	$(NNSTREAMER_GST_HOME)/nnstreamer_subplugin.c \
+	$(NNSTREAMER_GST_HOME)/tensor_common.c \
+	$(NNSTREAMER_GST_HOME)/tensor_repo.c \
+	$(NNSTREAMER_GST_HOME)/tensor_converter/tensor_converter.c \
+	$(NNSTREAMER_GST_HOME)/tensor_aggregator/tensor_aggregator.c \
+	$(NNSTREAMER_GST_HOME)/tensor_demux/gsttensordemux.c \
+	$(NNSTREAMER_GST_HOME)/tensor_filter/tensor_filter.c \
+	$(NNSTREAMER_GST_HOME)/tensor_merge/gsttensormerge.c \
+	$(NNSTREAMER_GST_HOME)/tensor_mux/gsttensormux.c \
+	$(NNSTREAMER_GST_HOME)/tensor_reposink/tensor_reposink.c \
+	$(NNSTREAMER_GST_HOME)/tensor_reposrc/tensor_reposrc.c \
+	$(NNSTREAMER_GST_HOME)/tensor_saveload/tensor_load.c \
+	$(NNSTREAMER_GST_HOME)/tensor_sink/tensor_sink.c \
+	$(NNSTREAMER_GST_HOME)/tensor_split/gsttensorsplit.c \
+	$(NNSTREAMER_GST_HOME)/tensor_transform/tensor_transform.c
+
+LOCAL_C_INCLUDES := $(NNSTREAMER_GST_HOME)/ \
+	$(NNSTREAMER_GST_HOME)/tensor_converter/ \
+	$(NNSTREAMER_GST_HOME)/tensor_aggregator/ \
+	$(NNSTREAMER_GST_HOME)/tensor_decoder/ \
+	$(NNSTREAMER_GST_HOME)/tensor_demux/ \
+	$(NNSTREAMER_GST_HOME)/tensor_filter/ \
+	$(NNSTREAMER_GST_HOME)/tensor_merge/ \
+	$(NNSTREAMER_GST_HOME)/tensor_mux/ \
+	$(NNSTREAMER_GST_HOME)/tensor_reposink/ \
+	$(NNSTREAMER_GST_HOME)/tensor_reposrc/ \
+	$(NNSTREAMER_GST_HOME)/tensor_saveload/ \
+	$(NNSTREAMER_GST_HOME)/tensor_sink/ \
+	$(NNSTREAMER_GST_HOME)/tensor_split/ \
+	$(NNSTREAMER_GST_HOME)/tensor_transform/
+
+
+# LOCAL_SHARED_LIBRARIES := gstreamer_android pangoft2 freetype
+
+LOCAL_SHARED_LIBRARIES := gstreamer-1.0 glib-2.0 gobject-2.0 intl gstcoreelements gstcoretracers gstadder gstapp gstaudioconvert gstaudiomixer gstaudioresample gstaudiorate gstaudioresample gstaudiotestsrc gstgio gstpango gstrawparse gsttypefindfunctions gstvideoconvert gstvideorate gstvideoscale gstvideotestsrc gstvolume gstautodetect gstvideofilter gstopengl gstopensles gmodule-2.0 gstcompositor ffi iconv png multifile gstbase-1.0 gstaudio-1.0 gstvideo-1.0 tag-1.0 orc app-1.0 badaudio badbase-1.0 gio-2.0 pangocairo  pango gthread cairo pixman fontconfig expat gstbadvideo gstcontroller jpeg graphene gstpbutils gstgl gstbadallocators gstallocators harfbuzz bz2 z
+
+
+
+LOCAL_C_INCLUDES += /work/taos/gst-android/gst_root_android-custom-1.12.4-ndkr12b-20190213-0900-decompress/arm64/include/gstreamer-1.0 \
+     /work/taos/gst-android/gst_root_android-custom-1.12.4-ndkr12b-20190213-0900-decompress/arm64/include/glib-2.0 \
+     /work/taos/gst-android/gst_root_android-custom-1.12.4-ndkr12b-20190213-0900-decompress/arm64/lib/glib-2.0/include \
+     /work/taos/gst-android/gst_root_android-custom-1.12.4-ndkr12b-20190213-0900-decompress/arm64/include
+
+include $(BUILD_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := test
+LOCAL_CFLAGS += -Ofast -mcpu=cortex-a53 -Ilz4-nougat/lib 
+TARGET_ARCH_ABI := arm64-v8a
+LOCAL_SRC_FILES += ../tests/nnstreamer_repo_dynamicity/tensor_repo_dynamic_test.c 
+#LOCAL_CXXFLAGS += -std=c++11
+LOCAL_LDFLAGS   := -fPIE -pie -Wl,-dynamic-linker,/data/nnstreamer/libandroid/linker64
+GSTREAMER_ROOT        := $(GSTREAMER_ROOT_ANDROID)/arm64
+NNSTREAMER_GST_HOME := ../gst/nnstreamer
+LOCAL_C_INCLUDES := $(NNSTREAMER_GST_HOME)
+
+LOCAL_SHARED_LIBRARIES := gstreamer-1.0 glib-2.0 gobject-2.0 intl gstcoreelements gstcoretracers gstadder gstapp gstaudioconvert gstaudiomixer gstaudioresample gstaudiorate gstaudioresample gstaudiotestsrc gstgio gstpango gstrawparse gsttypefindfunctions gstvideoconvert gstvideorate gstvideoscale gstvideotestsrc gstvolume gstautodetect gstvideofilter gstopengl gstopensles gmodule-2.0 gstcompositor ffi iconv png multifile gstbase-1.0 gstaudio-1.0 gstvideo-1.0 tag-1.0 orc app-1.0 badaudio badbase-1.0 gio-2.0 pangocairo  pango gthread cairo pixman fontconfig expat gstbadvideo gstcontroller jpeg graphene gstpbutils gstgl gstbadallocators gstallocators harfbuzz bz2 nnstreamer z
+
+
+LOCAL_C_INCLUDES += /work/taos/gst-android/gst_root_android-custom-1.12.4-ndkr12b-20190213-0900-decompress/arm64/include/gstreamer-1.0 \
+     /work/taos/gst-android/gst_root_android-custom-1.12.4-ndkr12b-20190213-0900-decompress/arm64/include/glib-2.0 \
+     /work/taos/gst-android/gst_root_android-custom-1.12.4-ndkr12b-20190213-0900-decompress/arm64/lib/glib-2.0/include \
+     /work/taos/gst-android/gst_root_android-custom-1.12.4-ndkr12b-20190213-0900-decompress/arm64/include
+
+
+
+GSTREAMER_ANDROID_INCLUDE := $(GSTREAMER_ROOT)/include
+
+include $(BUILD_EXECUTABLE)
diff --git a/jni/Application.mk b/jni/Application.mk
new file mode 100644
index 0000000..648d038
--- /dev/null
+++ b/jni/Application.mk
@@ -0,0 +1,4 @@
+LIBCXX_USE_GABIXX := true
+APP_ABI:=arm64-v8a
+APP_STL := c++_shared
+APP_PLATFORM := android-21
-- 
2.7.4

